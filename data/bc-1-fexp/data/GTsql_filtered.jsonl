{"instance_id": 0, "sol_sql": ["SELECT DISTINCT account_id FROM \"order\" GROUP BY account_id HAVING COUNT(order_id) > 1 AND (MAX(amount) - MIN(amount)) > 12000;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 1, "sol_sql": ["SELECT to_char(CreationDate, 'FMHH:MI:SS') FROM comments;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 2, "sol_sql": ["\n    UPDATE transactions_1k \n    SET Amount = 100 \n    FROM ( SELECT customerid, transactionid FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub \n    JOIN customers c ON c.customerid = sub.customerid WHERE transactions_1k.transactionid = sub.transactionid RETURNING transactions_1k.transactionid, c.Segment;\n   "], "test_cases": ["\nimport datetime\n\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    assert pred_query_result == [(947, 'SME'), (988, 'KAM')]"]}
{"instance_id": 3, "sol_sql": ["SELECT users.Id, COUNT(posts.Id) FILTER (WHERE AnswerCount > 0) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 4, "sol_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ), CTE2 AS ( SELECT link_to_event, COUNT(budget_id) AS count FROM budget GROUP BY link_to_event) SELECT CTE.link_to_event, CTE.count AS newCount, CTE2.count AS oldCount FROM CTE2 JOIN CTE ON CTE2.link_to_event = CTE.link_to_event WHERE CTE2.count != CTE.count;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 5, "sol_sql": ["SELECT t1.* FROM cards t1 JOIN (SELECT MIN(id) AS id FROM cards GROUP BY artist) t2 ON t1.id = t2.id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    artist_list = sorted([tup[1] for tup in pred_query_result])\n    assert artist_list == ['Daarken', 'Ralph Horsley']"]}
{"instance_id": 6, "sol_sql": ["SELECT *\nFROM transactions_1k\nWHERE CustomerID = 3\n  AND Date = '2012-08-24'\n\nUNION ALL\n\nSELECT *\nFROM transactions_1k\nWHERE CustomerID = 7626\n  AND Date = '2012-08-24'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM transactions_1k\n    WHERE CustomerID = 3\n      AND Date = '2012-08-24'\n  );\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 7, "sol_sql": ["SELECT 'SELECT ' || STRING_AGG('a.' || column_name, ', ') || ' FROM account AS a' FROM information_schema.columns WHERE table_name = 'account' AND table_schema = 'public' AND column_name NOT IN ('account_id', 'date');"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_2 = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_2 = execute_queries(sol_sqls, db_name, conn)\n    pred_sqls_2 = remove_distinct(pred_sqls_2[0][0])\n    sol_sqls_2 = remove_distinct(sol_sqls_2[0][0])\n    result = ex_base(pred_sqls_2, sol_sqls_2, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 8, "sol_sql": ["SELECT *\nFROM\n(\n  SELECT DISTINCT ON (account_id) *\n  FROM\n  (\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        0 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n        AND l.date >= (NOW() - INTERVAL '48 hours')\n      ORDER BY l.date DESC NULLS LAST\n      LIMIT 6\n    )\n    UNION\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        1 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n    )\n  ) t\n  ORDER BY account_id, priority\n) t\nORDER BY priority, loan_date DESC;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": 9, "sol_sql": ["SELECT json_agg(events_array) AS all_events\nFROM (\n  SELECT \n    json_agg(\n      json_build_object(\n        'link_to_member', link_to_member,\n        'link_to_event',  link_to_event\n      )\n    ) AS events_array\n  FROM attendance\n  GROUP BY link_to_event\n) sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def compare_array_of_arrays(arr1, arr2):\n        assert arr1 == arr2, \"The two array-of-array structures do not match.\"\n        return 1\n    \n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = compare_array_of_arrays(pred_query_result[0][0][0], sol_query_result[0][0][0])\n    return result"]}
{"instance_id": 10, "sol_sql": ["SELECT generate_series(\n  EXTRACT(YEAR FROM MIN(date)::timestamptz AT TIME ZONE 'UTC')::int,\n  EXTRACT(YEAR FROM MAX(date)::timestamptz AT TIME ZONE 'UTC')::int\n)::text AS the_year\nFROM loan;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": 11, "sol_sql": ["SELECT *, MAX(amount) OVER (PARTITION BY account_id) \"max\" FROM loan"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 12, "sol_sql": ["WITH ins AS (INSERT INTO cards (uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT (uuid) DO UPDATE SET uuid = NULL WHERE FALSE RETURNING id) SELECT id FROM ins UNION ALL SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' LIMIT 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][0] is not None, 'The returned ID should not be None'\n    test_pred_query_result_1 = execute_queries([\"SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c';\"], db_name, conn)[0]\n    assert pred_query_result[0][0] == test_pred_query_result_1[0][0], f'Expected ID to match, but found {pred_query_result[0][0]} and {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": 13, "sol_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    today = execute_queries([\"SELECT CURRENT_DATE\"], db_name, conn)[0][0][0]\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][4] == 'UPDATE', f'Expected operation_type to be UPDATE, but found {pred_query_result[0][4]}'\n    assert pred_query_result[0][3] == today, f'Expected date is updated to today {today}, but found {pred_query_result[0][3]}'\n    test_query_result_1 = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (22222, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;\"], db_name, conn)[0]\n    assert test_query_result_1[0][4] == 'INSERT', f'Expected operation_type to be INSERT, but found {test_query_result_1[0][4]}'"]}
{"instance_id": 14, "sol_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table, a.attname as base_col, (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table, UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col, pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey) WHERE c.confrelid = (select oid from pg_class where relname = 'users') AND c.confrelid!=c.conrelid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 15, "sol_sql": ["SELECT bank, first_value(bank) over (partition by account_id order by date rows between current row and unbounded following) as next_bank FROM trans WHERE bank is not null ORDER BY account_id, date;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 16, "sol_sql": ["SELECT t1.team_api_id, t1.team_short_name, t2.buildUpPlaySpeed FROM Team t1 INNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 17, "sol_sql": ["WITH years AS ( SELECT date_trunc('year', date) as year, COUNT(*) as count FROM trans GROUP BY 1 UNION ALL SELECT date_trunc('year', date) as year, COUNT(*) as count FROM loan GROUP BY 1 ) SELECT year, SUM(count) as count FROM years GROUP BY year ORDER BY year;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 18, "sol_sql": ["WITH gen_transactions AS (SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER))), shuffle AS (SELECT CustomerID, Amount, row_number() OVER (ORDER BY random()) AS rn FROM gen_transactions) SELECT CustomerID, Amount FROM shuffle WHERE rn <= 5 ORDER BY rn;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 5, f'Expected 5 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(set(row[0] for row in pred_query_result)) == 5, 'All CustomerIDs should be unique'\n    "]}
{"instance_id": 19, "sol_sql": ["\nSELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency\nFROM (\n    SELECT DISTINCT ON (t.k_symbol) \n           t.k_symbol, t.operation, t.amount, t.balance, t.account_id, t.date\n    FROM trans t\n    WHERE t.account_id = 1\n    AND t.type = 'PRIJEM'\n    ORDER BY t.k_symbol, t.date\n) t\nINNER JOIN account a ON t.account_id = a.account_id LIMIT 100\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_UROK = [i for i, row in enumerate(pred_query_result) if row[0] == 'UROK']\n    row_n = row_with_UROK[0]\n    assert pred_query_result[row_n][1] is None, f'Expected operation to be NULL, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 19, f'Expected amount to be 19, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 17298, f'Expected balance to be 17298, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_NULL = [i for i, row in enumerate(pred_query_result) if row[0] is None]\n    row_n = row_with_NULL[0]\n    assert pred_query_result[row_n][1] == 'VKLAD', f'Expected operation to be VKLAD, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 1000, f'Expected amount to be 1000, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 1000, f'Expected balance to be 1000, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    "]}
{"instance_id": 20, "sol_sql": ["SELECT player_api_id, date, overall_rating FROM Player_Attributes ORDER BY ROW_NUMBER() OVER(PARTITION BY player_api_id ORDER BY date DESC) FETCH FIRST 1 ROWS WITH TIES;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 21, "sol_sql": ["CREATE OR REPLACE FUNCTION get_user_ages() RETURNS setof numeric AS $BODY$ DECLARE curr_age  text; BEGIN FOR curr_age IN SELECT Age FROM users LOOP BEGIN RETURN NEXT curr_age::numeric; EXCEPTION WHEN OTHERS THEN NULL; END; END LOOP; END $BODY$  LANGUAGE plpgsql; SELECT * FROM get_user_ages();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT count(*) FROM users;\"], db_name, conn)\n    ori_count = res[0][0]\n    res, _, _ = execute_queries([\"SELECT count(*) FROM get_user_ages();\"], db_name, conn)\n    next_count = res[0][0]\n    assert next_count ==  (ori_count-1), f'Expected 40325 row in get_user_ages table, got {next_count}'\n    res,_, _ = execute_queries([\"SELECT count(get_user_ages) FROM get_user_ages() where get_user_ages = 31 GROUP BY get_user_ages order by get_user_ages;\"], db_name,conn)\n    init_res = res[0][0]\n    res, _, _ = execute_queries([\"select count(age) from users where age = '31' group by age order by age ;\"], db_name,conn)\n    other_res = res[0][0]\n    assert init_res == other_res, f'Expected same result, got {init_res} and {other_res}'\n    \n"]}
{"instance_id": 22, "sol_sql": ["SELECT * FROM cards WHERE  3 = (CASE WHEN availability = 'paper' THEN 1 ELSE 0 END) + (CASE WHEN bordercolor = 'black' THEN 1 ELSE 0 END) + (CASE WHEN rarity = 'uncommon' THEN 1 ELSE 0 END) + (CASE WHEN types = 'Creature' THEN 1 ELSE 0 END);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 23, "sol_sql": ["SELECT d.driverId, COALESCE(SUM(r.points), 0) AS total_points FROM drivers d LEFT JOIN results r ON d.driverId = r.driverId GROUP BY d.driverId"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 24, "sol_sql": ["SELECT \n    sqA.alignment_count     AS total_by_alignment,\n    A.alignment             AS alignment,\n    R.race                  AS race,\n    sqAR.alignment_race_count AS count_by_alignment_race\nFROM\n    (\n       SELECT\n           alignment_id,\n           COUNT(*) AS alignment_count\n       FROM superhero\n       GROUP BY alignment_id\n    ) sqA\n\n    INNER JOIN\n    (\n       SELECT\n           alignment_id,\n           race_id,\n           COUNT(*) AS alignment_race_count\n       FROM superhero\n       GROUP BY alignment_id, race_id\n    ) sqAR ON sqA.alignment_id = sqAR.alignment_id\n\n    INNER JOIN alignment A ON sqA.alignment_id = A.id\n\n    INNER JOIN race R ON sqAR.race_id = R.id\nORDER BY\n    A.alignment,\n    R.race;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 25, "sol_sql": ["select driverId, points, array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred = execute_queries(pred_sqls,db_name,conn)\n    sol = execute_queries(sol_sqls,db_name,conn)\n    assert pred == sol\n    return pred == sol"]}
{"instance_id": 26, "sol_sql": ["WITH cte AS (\n    SELECT\n        p.*,\n        CEIL( (ROW_NUMBER() OVER (\n                 PARTITION BY raceId \n                 ORDER BY time::time\n               ) + 1 ) / 2.0\n        ) AS rn\n    FROM pitStops p\n    WHERE raceId = 842\n),\ncte2 AS (\n    SELECT\n        rn,\n        MIN(time::time) AS starttime,\n        MAX(time::time) AS endtime,\n        CAST(MAX(time::time) - MIN(time::time) AS time) AS total_pause\n    FROM cte\n    GROUP BY rn\n)\nSELECT\n    MAX(endtime) AS endtime,\n    MIN(starttime) AS starttime,\n    CAST(SUM(total_pause) AS time) AS total_pit_stop_duration\nFROM cte2;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 27, "sol_sql": ["SELECT json_object_agg(label, groupedMolecules) AS molecules_by_label\nFROM (\n  SELECT label,\n         json_agg(\n           json_build_object(\n             'molecule_id', molecule.molecule_id,\n             'atoms', (\n               SELECT json_agg(\n                 json_build_object(\n                   'atom_id', atom.atom_id,\n                   'element', atom.element\n                 )\n               )\n               FROM atom\n               WHERE atom.molecule_id = molecule.molecule_id\n             ),\n             'bonds', (\n               SELECT json_agg(\n                 json_build_object(\n                   'bond_id', bond.bond_id,\n                   'bond_type', bond.bond_type\n                 )\n               )\n               FROM bond\n               WHERE bond.molecule_id = molecule.molecule_id\n             )\n           )\n         ) AS groupedMolecules\n  FROM molecule\n  GROUP BY label\n) AS sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def json_matches_gold(generated_json, gold_json):\n        # If either object is a string, parse it as JSON\n        if isinstance(generated_json, str):\n            generated_json = json.loads(generated_json)\n        if isinstance(gold_json, str):\n            gold_json = json.loads(gold_json)\n\n        # Return whether the Python structures match exactly\n        return generated_json == gold_json\n    \n    sol = execute_queries(sol_sqls,db_name,conn)\n    pred = execute_queries(pred_sqls,db_name,conn)\n    assert json_matches_gold(sol[0], pred[0])\n    return json_matches_gold(sol[0], pred[0])"]}
{"instance_id": 28, "sol_sql": ["SELECT\n    molecule_id,\n    COUNT(DISTINCT CASE WHEN element = 'na' THEN 1 END)         AS na_atoms,\n    COUNT(DISTINCT CASE WHEN element IN ('c', 'cl') THEN molecule_id END) AS c_atoms\nFROM atom\nGROUP BY molecule_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 29, "sol_sql": ["SELECT date_trunc('hour', \"date\"::timestamp), home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY date_trunc('hour', \"date\"::timestamp), home_team_api_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 30, "sol_sql": ["WITH cte AS (\n    SELECT\n        m.*,\n        SUM(\n          CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END\n        ) OVER (ORDER BY m.date) AS grp\n    FROM match AS m\n),\naggregates AS (\n    SELECT\n        grp,\n        MAX(date) FILTER (WHERE home_team_goal = away_team_goal) AS draw_date,\n        1 AS invoiced,\n        SUM(home_team_goal + away_team_goal) AS total_goals\n    FROM cte\n    GROUP BY grp\n)\nSELECT \n    grp,\n    draw_date AS date,\n    invoiced,\n    total_goals AS amount\nFROM aggregates\nWHERE draw_date IS NOT NULL\nORDER BY grp;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 31, "sol_sql": ["WITH last_per_station AS (\n  SELECT\n    t.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY customerid, gasstationid\n      ORDER BY transactionid DESC\n    ) AS rn\n  FROM transactions_1k t\n),\nDataSource AS (\n  SELECT\n    lps.*,\n    CASE WHEN amount < 10 THEN transactionid END AS fail_id,\n    CASE WHEN amount >= 10 THEN transactionid END AS pass_id\n  FROM last_per_station lps\n  WHERE rn = 1\n),\nCalculated AS (\n  SELECT\n    ds.*,\n    MIN(fail_id) OVER (PARTITION BY customerid) AS earliest_fail_id,\n    MAX(pass_id) OVER (PARTITION BY customerid) AS last_pass_id\n  FROM DataSource ds\n)\nSELECT\n  customerid,\n  transactionid,\n  date,\n  time,\n  gasstationid,\n  productid,\n  amount,\n  price\nFROM Calculated\nWHERE\n  (earliest_fail_id IS NOT NULL AND fail_id = earliest_fail_id)\n  OR\n  (earliest_fail_id IS NULL AND pass_id = last_pass_id);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 32, "sol_sql": ["\n        SELECT \n            CASE \n                WHEN EXISTS (\n                    SELECT 1 \n                    FROM pg_indexes \n                    WHERE tablename = 'account' \n                    AND indexname = 'ix_account'\n                ) THEN TRUE\n                ELSE FALSE\n            END AS index_exists;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == True\n    queries = [\"DROP INDEX ix_account;\"]\n    execute_queries(queries,db_name,conn)\n    res, _, _ = execute_queries(pred_sqls,db_name,conn)\n    assert res[0][0] == False\n    "]}
{"instance_id": 33, "sol_sql": ["\n        select posttypeid,\n        sum(case when tags like '%bayesian%'\n                or tags like '%distributions%'\n            then 1 else 0 end) as keyword_count\n        from posts\n        group by posttypeid\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == 2\n    assert pred_query_result[0][1] == 1\n    assert pred_query_result[1][0] == 1\n    assert pred_query_result[1][1] == 2\n    "]}
{"instance_id": 34, "sol_sql": ["SELECT\n    c.id,\n    c.text,\n    (\n        SELECT array_agg(matches[1])\n        FROM regexp_matches(\n            c.text,\n            '(\\{[^{}]*\\})',\n            'g'\n        ) AS matches\n    ) AS bracketed_tokens\nFROM cards AS c;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": 35, "sol_sql": ["WITH ranked_races AS (SELECT gender_id, race_id, COUNT(*) AS count, DENSE_RANK() OVER (PARTITION BY gender_id ORDER BY COUNT(*) DESC) AS rank FROM superhero GROUP BY gender_id, race_id) SELECT gender_id, race_id, count FROM ranked_races WHERE rank <= 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 36, "sol_sql": ["SELECT r.* FROM unnest(ARRAY['6d268c95-c176-5766-9a46-c14f739aba1c', '56f4935b-f6c5-59b9-88bf-9bcce20247ce', '8dfc67e9-8323-5d1f-9e25-9f9394abd5a0', '5ac794d2-4c66-5332-afb1-54b24bc11823', '60f49caf-3583-5f85-b4b3-08dca73a8628']::uuid[]) AS p(uuid) CROSS JOIN LATERAL (SELECT id, date, text, uuid FROM rulings r WHERE r.uuid = p.uuid::varchar ORDER BY date DESC LIMIT 3) r ORDER BY uuid, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 37, "sol_sql": ["SELECT s.cds, s.cds IN (SELECT cdscode FROM frpm) AS frpm_exists FROM satscores s order by cds"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 38, "sol_sql": ["SELECT id, ((gk_diving + gk_handling + gk_kicking + gk_positioning + gk_reflexes) - GREATEST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes) - LEAST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes)) / 3.0 AS adjusted_average FROM player_attributes ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 39, "sol_sql": ["\n        select account_id, date, \n        sum(amount) OVER w as total_amount, \n        sum(balance) OVER w as total_balance, \n        count(trans_id) OVER w as total_transactions\n        from trans WINDOW w AS (PARTITION BY account_id, date);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    \n    lower_sqls = ' '.join(pred_sqls)\n    lower_sqls = lower_sqls.lower()\n    keyword_count = lower_sqls.count('partition by')\n    assert keyword_count == 1, f\"You need to just use one PARTITION definition.\"\n    "]}
{"instance_id": 40, "sol_sql": ["\n        SELECT * FROM transactions_1k WHERE Date < '2012-08-24' OR (Date = '2012-08-24' AND Time > '10:00:00') OR (Date = '2012-08-24' AND Time = '10:00:00' AND Amount < 20);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": 41, "sol_sql": ["\n        SELECT client.gender, loan.amount, loan.duration, account.date FROM loan JOIN account ON loan.account_id = account.account_id JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE loan.date BETWEEN '1996-01-01' AND '1996-12-31';\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": 42, "sol_sql": ["WITH deleted_rows AS (DELETE FROM superhero WHERE id = 999 RETURNING 1) SELECT COALESCE((SELECT * FROM deleted_rows), 0)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 1, f'Expected 1 row, but found {len(pred_sqls_result)} rows'"]}
{"instance_id": 43, "sol_sql": ["SELECT name, convertedManaCost, ROUND(avg(convertedManaCost::numeric) OVER(ORDER BY id ROWS BETWEEN 8 PRECEDING AND CURRENT ROW), 2) AS nine_card_avg FROM cards WHERE name LIKE 'A%' ORDER BY id DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 44, "sol_sql": ["SELECT * FROM trans WHERE EXTRACT(MONTH FROM date) = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(DAY FROM date) = EXTRACT(DAY FROM CURRENT_DATE) ORDER BY date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 45, "sol_sql": ["\nSELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected at least one result with fastestLapTime = 1:35.405, but found none.'\n    assert all(row[0] is not None for row in test_pred_query_result_1), 'Expected all resultIds to be valid, but found NULL values.'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_2) == 1, f'Expected exactly 1 result with fastestLapTime = 1:35.405, but found {len(test_pred_query_result_2)} results.'\n    assert test_pred_query_result_2[0][0] == 23, f'Expected resultId to be 23, but found {test_pred_query_result_2[0][0]}.'\n"]}
{"instance_id": 46, "sol_sql": ["\nSELECT raceId,\n       jsonb_object_agg(COALESCE(position::text, 'Unknown') , COALESCE(cnt::text, '0')) AS json_count\nFROM (\n    SELECT raceId,\n           position,\n           COUNT(*) AS cnt\n    FROM results\n    GROUP BY raceId, position\n) AS aggregated_counts\nGROUP BY raceId\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 1;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_1[0][0] == 1, f'Expected count of position 1 in race 19 to be 1, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 2;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_2[0][0] == 1, f'Expected count of position 2 in race 19 to be 1, but found {test_pred_query_result_2[0][0]}'\n    test_pred_query_result_3 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 3;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_3[0][0] == 1, f'Expected count of position 3 in race 19 to be 1, but found {test_pred_query_result_3[0][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) > 0, 'Expected at least one row in the result, but found none.'\n    assert isinstance(pred_query_result[0][1], dict), 'Expected json_count to be a dictionary, but found something else.'\n    assert '1' in pred_query_result[0][1], 'Expected position 1 to be included in the json_count for raceId 1.'\n"]}
{"instance_id": 47, "sol_sql": ["\nSELECT * FROM Match WHERE (match_api_id, date, id) < (492473, '2008-08-17 00:00:00', 1) ORDER BY match_api_id DESC, date DESC, id DESC LIMIT 3;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) == 3, f'Expected 3 rows, but found {len(test_pred_query_result_1)} rows'\n    assert test_pred_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_pred_query_result_1[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) == 3, f'Expected 3 rows, but found {len(test_sol_query_result_1)} rows'\n    assert test_sol_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_sol_query_result_1[0][0]}'\n    "]}
{"instance_id": 48, "sol_sql": ["\nSELECT s.School FROM schools s WHERE s.County IN ('Alameda', 'Contra Costa') \nGROUP BY s.School HAVING COUNT(DISTINCT s.County) = 2;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_pred_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_pred_query_result_1[1][0]}'\n    assert test_pred_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_pred_query_result_1[2][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_sol_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_sol_query_result_1[1][0]}'\n    assert test_sol_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_sol_query_result_1[2][0]}'\n    "]}
{"instance_id": 49, "sol_sql": ["SELECT DISTINCT ON (name) raceid, name, date FROM races ORDER BY name, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 50, "sol_sql": ["SELECT t.team_name, o.outcome FROM (VALUES('Team A'),('Team B')) AS t(team_name) CROSS JOIN (VALUES('win'),('lose'),('draw')) AS o(outcome);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'european_football_2', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'european_football_2', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 51, "sol_sql": ["\nWITH RankedFRPM AS (\n    SELECT *, \n           ROW_NUMBER() OVER (\n               PARTITION BY \"County Code\" \n               ORDER BY \"Enrollment (K-12)\" DESC NULLS LAST\n           ) AS rn \n    FROM frpm\n    WHERE \"County Code\" IS NOT NULL AND \"Enrollment (K-12)\" IS NOT NULL\n) \nSELECT * \nFROM RankedFRPM \nWHERE rn = 2;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 52, "sol_sql": ["SELECT d.forename, d.surname, r.race_results\nFROM (\n   SELECT driverid, \n          jsonb_agg(jsonb_build_object('laps', r.laps, 'position', r.position)) AS race_results\n   FROM results r\n   WHERE EXISTS (\n      SELECT 1 \n      FROM results r1\n      WHERE r1.driverid = r.driverid\n      AND   r1.laps = 56\n      AND   r1.position = 1\n   )\n   GROUP BY driverid\n) r\nJOIN drivers d ON d.driverid = r.driverid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(sol_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 53, "sol_sql": ["SELECT DISTINCT id, acceptedanswerid, posttypeid, score\nFROM (\n  SELECT p.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE p.score >= 20\n  UNION ALL\n  SELECT c.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE NOT p.score >= 20 AND c.score >= 20\n) x;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 54, "sol_sql": ["SELECT DISTINCT s.id \nFROM superhero s \nWHERE s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Flight'\n    )\n) \nAND s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Telepathy'\n    )\n) \nAND s.id NOT IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id NOT IN (\n        (SELECT id FROM superpower WHERE power_name = 'Flight'), \n        (SELECT id FROM superpower WHERE power_name = 'Telepathy')\n    )\n);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 55, "sol_sql": ["SELECT to_timestamp(percentile_cont(0.5) within group (ORDER by cast (extract(epoch from releasedate) as integer)))::date FROM sets"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 56, "sol_sql": ["WITH RECURSIVE recuree AS (SELECT id AS league_id, name FROM League UNION ALL SELECT L.id AS league_id, L.name FROM League L JOIN recuree R ON L.id = R.league_id) SELECT * FROM recuree LIMIT 50;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 57, "sol_sql": ["SELECT r.name, r.date, ARRAY_AGG(lt.milliseconds ORDER BY lt.lap) AS lap_times FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId WHERE lt.driverId = 1 GROUP BY r.name, r.date ORDER BY r.date"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": 58, "sol_sql": ["WITH LatestLabs AS (SELECT ID, \"Examination Date\", Thrombosis, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY \"Examination Date\" DESC) AS rn FROM Examination) SELECT ID, MAX(CASE WHEN rn = 1 THEN Thrombosis END) AS Thrombosis_1, MAX(CASE WHEN rn = 2 THEN Thrombosis END) AS Thrombosis_2 FROM LatestLabs WHERE rn <= 2 GROUP BY ID"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 59, "sol_sql": ["with connections as ( select atom_id as atom from connected union all select atom_id2 as atom from connected ) select atom as id, count(*) as num from connections group by atom having count(*) = (select max(cnt) from (select count(*) as cnt from connections group by atom) as max_connections);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 60, "sol_sql": ["SELECT raceId, name, year, COUNT(*) OVER (PARTITION BY year) as same_year_races FROM races;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 61, "sol_sql": ["with hero_attribute_data (hero_id, attribute_id, max_score, year_1, year_2, year_3, year_4, year_5) as (values (1, 1, 80, 80, 80, 80, null, 80), (2, 2, 90, 90, 85, 90, 88, 90), (3, 3, 75, 75, 70, null, 75, 75), (4, 4, 60, null, 60, 60, 60, null)), score_check as (select *, case when (coalesce(year_1::character, 'x') || coalesce(year_2::character, 'x') || coalesce(year_3::character, 'x') || coalesce(year_4::character, 'x') || coalesce(year_5::character, 'x') ~ '\\d+x\\d+' or year_1 <> max_score or year_2 <> max_score or year_3 <> max_score or year_4 <> max_score or year_5 <> max_score) then false else true end is_a_match from hero_attribute_data) select * from score_check where is_a_match is false;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 62, "sol_sql": ["WITH norm_matches AS ( SELECT id AS match_id, home_team_api_id AS team_id, home_team_goal AS goals, CASE WHEN home_team_goal > away_team_goal THEN 'W' WHEN home_team_goal = away_team_goal THEN 'D' WHEN home_team_goal < away_team_goal THEN 'L' END AS outcome FROM match UNION ALL SELECT id AS match_id, away_team_api_id AS team_id, away_team_goal AS goals, CASE WHEN home_team_goal > away_team_goal THEN 'L' WHEN home_team_goal = away_team_goal THEN 'D' WHEN home_team_goal < away_team_goal THEN 'W' END AS outcome FROM match ), points (outcome, value) AS ( VALUES ('W', 3), ('D', 1), ('L', 0) ) SELECT t.team_long_name, count(1) AS matches, count(1) filter (WHERE m.outcome = 'W') AS victories, count(1) filter (WHERE m.outcome = 'L') AS defeats, count(1) filter (WHERE m.outcome = 'D') AS draws, sum(p.value) AS score FROM team t JOIN norm_matches m ON m.team_id = t.team_api_id JOIN points p ON p.outcome = m.outcome GROUP BY t.team_long_name ORDER BY t.team_long_name"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 63, "sol_sql": ["SELECT id, COALESCE(MAX(CASE WHEN diagnosis = 'SLE' THEN 'TRUE' END), 'FALSE') AS SLE, COALESCE(MAX(CASE WHEN diagnosis = 'PSS' THEN 'TRUE' END), 'FALSE') AS PSS, COALESCE(MAX(CASE WHEN diagnosis = 'RA susp.' THEN 'TRUE' END), 'FALSE') AS RA_susp FROM examination GROUP BY id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    global pred_query_result\n    assert len(pred_query_result) == 70, f'Expected 70 rows, but found {len(pred_query_result)} rows.'\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 64, "sol_sql": ["\nSELECT hero_id, attribute_value AS Difference FROM hero_attribute \nJOIN attribute ON hero_attribute.attribute_id = attribute.id GROUP BY hero_id, attribute_value \nHAVING COUNT(DISTINCT attribute_value) > 1 UNION ALL SELECT hero_id, attribute_value AS Difference \nFROM hero_attribute JOIN attribute ON hero_attribute.attribute_id = attribute.id \nGROUP BY hero_id, attribute_value HAVING COUNT(DISTINCT attribute_id) > 1 \nOR (COUNT(attribute_id) != COUNT(*) AND COUNT(DISTINCT attribute_id) > 0)\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'error_sql query did not return any records with attribute differences.'\n    assert test_pred_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_pred_query_result_1[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, 'sol_sql query did not return any records with attribute differences.'\n    assert test_sol_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_sol_query_result_1[0][1]}'\n"]}
{"instance_id": 65, "sol_sql": ["SELECT COUNT(*) AS streak_count, 'April Meeting' AS event_name, 'MST' AS timezone, MIN(min_ts) AS start_date, MAX(max_ts) AS end_date FROM ( SELECT *, the_day - row_number() OVER (ORDER BY the_day)::INT AS streak FROM ( SELECT (event_date::TIMESTAMP AT TIME ZONE 'UTC' AT TIME ZONE 'MST')::date AS the_day , count(*) AS ct, min(event_date) AS min_ts, max(event_date) AS max_ts FROM event WHERE event_name = 'April Meeting' GROUP  BY 1) sub1) sub2 GROUP  BY streak ORDER  BY end_date DESC LIMIT  1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_query_result_1[0][1] == 'April Meeting', 'The event name should be April Meeting.'\n    assert pred_query_result_1[0][2] == 'MST', 'The timezone should be MST.'\n    assert pred_query_result_1[0][0] > 0, 'The streak count should be greater than 0.'\n    test_pred_query_result_1 = execute_queries([\"SELECT MIN(event_date) AS start_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][3] == str(test_pred_query_result_1[0][0]), f'Expected start_date to be {test_pred_query_result_1[0][0]}, but found {pred_query_result_1[0][3]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT MAX(event_date) AS end_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][4] == str(test_pred_query_result_2[0][0]), f'Expected end_date to be {test_pred_query_result_2[0][0]}, but found {pred_query_result_1[0][4]}'\n    \n    "]}
{"instance_id": 66, "sol_sql": ["select id, date, got, gpt from (select lab1.*, row_number() over (partition by lab1.id order by lab1.date) as rn from laboratory lab1 join (select id, date, got, gpt from (select lab.*, row_number() over (partition by lab.id order by lab.date desc) rn from laboratory lab) lab where rn = 1 ) lab2 on lab2.id = lab1.id and lab1.got = lab2.got and lab1.gpt = lab2.gpt) lab where rn = 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 67, "sol_sql": ["WITH constructor_roles AS ( SELECT 18 race_id, 1 constructor_id, false customer_billing, true commander, true agent UNION ALL SELECT 18, 2, true, false, false ), tmp AS ( SELECT n.race_id id, array_agg( ARRAY[ CASE WHEN n.customer_billing = TRUE THEN 'AR (Customer Billing)' END, CASE WHEN n.commander = TRUE THEN 'AP (Commander)' END, CASE WHEN n.agent = TRUE THEN 'AP (Agent)' END ] ) AS finance_array FROM constructor_roles n WHERE n.race_id = 18 AND (n.customer_billing = TRUE or n.commander = TRUE or n.agent = TRUE) GROUP BY race_id ) SELECT id, array_to_string(array(select distinct e from unnest(finance_array) as a(e)), ', ') FROM tmp"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 68, "sol_sql": ["select distinct rarity, first_value(id) over(partition by rarity order by convertedmanacost desc nulls last, edhrecrank desc nulls last, multiverseid asc) from cards;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 69, "sol_sql": ["SELECT COALESCE (ARRAY_AGG (json_build_object ('client_id', client.client_id, 'gender', client.gender, 'birth_date', client.birth_date)) FILTER (WHERE client.client_id IS NOT NULL), ARRAY[]::json[]) AS clients FROM client;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0];\n    assert pred_query_result_1[0][0] != '[null]', 'Expected an empty array instead of [null] when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n    assert isinstance(pred_query_result_1[0][0], list), 'Expected the result to be a list, but found {type(pred_query_result_1[0][0])}'\n    if len(pred_query_result_1[0][0]) == 0:\n        assert pred_query_result_1[0][0] == '[]', 'Expected an empty array when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n\n    if len(pred_query_result_1[0][0]) > 0:\n        for item in pred_query_result_1[0][0]:\n            assert 'client_id' in item, 'Each result should have client_id'\n            assert 'gender' in item, 'Each result should have gender'\n            assert 'birth_date' in item, 'Each result should have birth_date'\n            assert item['client_id'] is not None, 'client_id should not be NULL'\n\n\n    "]}
{"instance_id": 70, "sol_sql": ["SELECT raceid, laps AS modal_laps FROM (SELECT raceid, laps, COUNT(*) AS freq, MIN(resultid) AS first_occurrence, ROW_NUMBER() OVER (PARTITION BY raceid ORDER BY COUNT(*) DESC, MIN(resultid) ASC) AS rn FROM results GROUP BY raceid, laps) sub WHERE rn = 1 ORDER BY raceid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 71, "sol_sql": ["with hero_attribute(hero_id, attribute_id, attribute_value) as ( values (1, 1, 80), (2, 1, 75), (3, 1, 95), (4, 1, 85), (5, 1, 90), (6, 1, 70) ), running as ( select hero_id, sum(attribute_value) over (order by hero_id rows between 2 preceding and 3 following) from hero_attribute) select sum from running where (hero_id-1) % 2 = 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 72, "sol_sql": ["SELECT DISTINCT ON (examination_year) c, \"ANA Pattern\", examination_year FROM (SELECT COUNT(\"ANA Pattern\") AS c, \"ANA Pattern\", EXTRACT(YEAR FROM \"Examination Date\") AS examination_year FROM examination WHERE EXTRACT(YEAR FROM \"Examination Date\") BETWEEN 1993 AND 1996 GROUP BY EXTRACT(YEAR FROM \"Examination Date\"), \"ANA Pattern\") AS sub ORDER BY examination_year, c DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 4, f'Expected 4 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": 73, "sol_sql": ["SELECT rs.raceId as race_id, (SELECT string_agg(constructorId::TEXT, ',' ORDER BY res.resultId) FROM results res WHERE res.raceId = rs.raceId) as constructor_ids, (SELECT string_agg(p.stop::TEXT, ', ' ORDER BY p.raceId) FROM pitstops p WHERE rs.raceId = p.raceId) AS stops FROM races rs"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 74, "sol_sql": ["select position, array_agg(driverid) as driverids from results where driverid not in (select max(driverid) from results group by position) group by position order by position;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 75, "sol_sql": ["SELECT * \nFROM (\n  SELECT gender_id, COUNT(*) as cnt1 \n  FROM superhero \n  WHERE gender_id IN (1, 2) \n  GROUP BY gender_id\n) AS g1\nFULL OUTER JOIN (\n  SELECT alignment_id, COUNT(*) as cnt2 \n  FROM superhero \n  WHERE alignment_id IN (1, 2) \n  GROUP BY alignment_id\n) AS a1\nON g1.gender_id = a1.alignment_id\nWHERE COALESCE(g1.gender_id, a1.alignment_id) IN (1, 2);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 76, "sol_sql": ["SELECT artist, setcode, COUNT(setcode) AS counter\nFROM cards\nGROUP BY artist, setcode\nORDER BY MAX(COUNT(*)) OVER (PARTITION BY artist) DESC, artist, COUNT(*) DESC, setcode;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 77, "sol_sql": ["SELECT y.district_id, \n       array_agg(y.loan_id) FILTER (WHERE y.status IN ('A', 'B')) AS type_A_B, \n       array_agg(y.loan_id) FILTER (WHERE y.status = 'C') AS type_C\nFROM (\n  SELECT x.district_id, l.loan_id, l.status\n  FROM loan l\n  JOIN account x ON l.account_id = x.account_id\n) y\nGROUP BY 1\nORDER BY 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f'Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}'\n"]}
{"instance_id": 78, "sol_sql": ["SELECT league_id, season, STRING_AGG(DISTINCT id::TEXT, ',') as match_ids, STRING_AGG(DISTINCT date:: TEXT, ',') AS match_dates FROM match WHERE season IS NOT NULL AND league_id IS NOT NULL AND date IS NOT NULL GROUP BY league_id, season order by league_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 79, "sol_sql": ["SELECT d.the_day AS \"Date\", COUNT(DISTINCT e.event_id) AS \"Number of Events\", AVG(b.avg_remaining) AS \"Avg Remaining Budget\" FROM (SELECT ts::date AS the_day FROM generate_series('2020-01-01'::timestamp, '2020-03-31'::timestamp, '1 day'::interval) AS ts) d LEFT JOIN \"event\" e ON e.event_date::date = d.the_day AND e.status IN ('Open', 'Closed') LEFT JOIN (SELECT link_to_event, SUM(remaining) as avg_remaining FROM budget GROUP BY link_to_event) b ON b.link_to_event = e.event_id GROUP BY d.the_day ORDER BY d.the_day;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    assert len(pred_query_result_1) == 91, f'Expected 91 rows, but found {len(pred_query_result_1)} rows'\n    assert str(pred_query_result_1[0][0]) == '2020-01-01', f'Expected the first date to be 2020-01-01, but found {pred_query_result_1[0][0]}'\n    assert str(pred_query_result_1[-1][0]) == '2020-03-31', f'Expected the last date to be 2020-03-31, but found {pred_query_result_1[-1][0]}'\n    assert pred_query_result_1[13][1] == 2, f'Expected the number of events on 2020-01-14 day to be 2, but found {pred_query_result_1[13][1]}'\n    assert pred_query_result_1[27][2] > 0, f'Expected the average remaining budget on 2020-01-28 day to be greater than 0, but found {pred_query_result_1[27][2]}'\n    assert pred_query_result_1[41][1] == 1, f'Expected the number of events on 2020-02-11 day to be 1, but found {pred_query_result_1[41][1]}'\n    assert pred_query_result_1[33][2] is None or pred_query_result_1[33][2] >= 0, f'Expected the average remaining budget on 2020-02-02 day to be 0 or NULL, but found {pred_query_result_1[33][2]}'\n\n    "]}
{"instance_id": 80, "sol_sql": ["SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1997 THEN trans.amount ELSE 0 END) AS a1997, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1998 THEN trans.amount ELSE 0 END) AS a1998 FROM trans WHERE trans.date >= '1997-01-01' AND trans.date < '1999-01-01' GROUP BY month ORDER BY 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    print(pred_query_result_1)\n    assert len(pred_query_result_1) == 12, f'Expected 12 rows (one for each month), but found {len(pred_query_result_1)} rows'\n    assert pred_query_result_1[0][0] == '01', 'The first month should be January (01).'\n    assert pred_query_result_1[-1][0] == '12', 'The last month should be December (12).'\n    assert pred_query_result_1[0][2] is not None, 'The sum of transactions for January 1998 should not be None.'\n    test_pred_query_result_1 = execute_queries([\"SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(trans.amount) AS total FROM trans WHERE EXTRACT(YEAR FROM trans.date) = 1997 GROUP BY month ORDER BY month;\"], db_name, conn)[0]\n    assert pred_query_result_1[0][1] == test_pred_query_result_1[0][1], f'Expected the sum of transactions for January 1997 to be {test_pred_query_result_1[0][1]}, but found {pred_query_result_1[0][1]}.'\n\n    "]}
{"instance_id": 81, "sol_sql": ["SELECT resultid FROM results where driverid in (3, 4) order by resultid DESC LIMIT 10"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 82, "sol_sql": ["WITH cte AS (SELECT driverid, points, (points * 100) as earnings FROM driverstandings) SELECT driverid, points, earnings, CASE WHEN earnings > 5000 THEN earnings * 0.2 WHEN earnings > 3000 THEN earnings * 0.15 ELSE null END AS bonus FROM cte"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count_price_times = sum(sql.lower().count('points * 100') for sql in pred_sqls)\n    assert count_price_times <= 3, f'Expected at most 3 occurrences of \"price * 100\" in the query, but got {count_price_times}.'\n"]}
{"instance_id": 83, "sol_sql": ["with dataset as (\n  SELECT \n      date,\n      COUNT(*) as rows_added\n  FROM\n      team_attributes\n  WHERE \n      date between '2010-01-01 00:00:00'\n      AND '2015-12-31 00:00:00'\n  GROUP BY \n      date\n )\nSELECT\n    COUNT(*) as total_days_in_result_set,\n    COUNT(DISTINCT rows_added) as total_days_w_distinct_record_counts,\n    COUNT(*) - COUNT(DISTINCT rows_added) as total_days_w_duplicate_record_counts,\n    COUNT(*) - COUNT(DISTINCT date) as duplicate_dates\nFROM dataset"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 84, "sol_sql": ["WITH cte_funding_count AS (SELECT fundingtype, COUNT(*) AS count FROM schools GROUP BY fundingtype), p as( SELECT fundingtype,  count,  ROUND(count*100./(SELECT SUM(count) FROM cte_funding_count),0) AS percent FROM cte_funding_count ) select fundingtype, count, case(row_number() over(order by percent desc)) when 1  then 100 - sum(percent) over(order by percent desc rows between 1 following and unbounded following)  else percent end pp from p"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    total = sum([item[2] for item in pred_sqls_result])\n    assert total == 100, f'Expected the total percentage is 100, but found {total}'"]}
{"instance_id": 85, "sol_sql": ["WITH RankedLabs AS (SELECT lab.date AS firstActivity, pat.ID as id, ROW_NUMBER() OVER (PARTITION BY pat.id ORDER BY lab.date ASC) AS rn FROM patient pat JOIN laboratory lab ON lab.id = pat.id AND lab.date <= pat.description AND lab.date > pat.\"First Date\" WHERE pat.sex = 'F') SELECT firstActivity, id FROM RankedLabs WHERE rn = 1 ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
