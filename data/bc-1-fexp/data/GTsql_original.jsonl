{"instance_id": 0, "sol_sql": ["SELECT DISTINCT account_id FROM \"order\" GROUP BY account_id HAVING COUNT(order_id) > 1 AND (MAX(amount) - MIN(amount)) > 12000;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 1, "sol_sql": ["SELECT to_char(CreationDate, 'FMHH:MI:SS') FROM comments;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 2, "sol_sql": ["\n    CREATE OR REPLACE FUNCTION total_loans()\n    RETURNS TRIGGER\n    AS $$\n    BEGIN \n        UPDATE loan_summary\n        SET total_loan_count = ( \n            SELECT COUNT(*) \n            FROM loan \n            WHERE loan.account_id = loan_summary.account_id\n              AND loan.status = 'A') \n        WHERE loan_summary.account_id = NEW.account_id; \n        RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql;\n    ", "\n    CREATE TRIGGER tr_total_loans AFTER UPDATE OF status ON loan FOR EACH ROW EXECUTE PROCEDURE total_loans();\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT account_id, total_loan_count FROM loan_summary ORDER BY account_id LIMIT 1;\"], db_name,conn)\n    account_id, loan_count = res[0][0], res[0][1]\n    res, _, _ = execute_queries([f\"SELECT loan_id, account_id FROM loan WHERE account_id = {account_id} AND status = 'A' LIMIT 1;\"], db_name,conn)\n    loan_id = res[0][0]\n    check_sql = [f\"UPDATE loan SET status = 'B' WHERE loan_id = {loan_id};\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT total_loan_count FROM loan_summary WHERE account_id = {account_id};\"], db_name,conn)\n    new_count = res[0][0]\n    assert new_count == (loan_count - 1), f\"The trigger does not work.\"\n"]}
{"instance_id": 3, "sol_sql": ["ALTER TYPE buildupplayspeedclass_enum ADD VALUE 'Very Fast';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT id FROM team_attributes LIMIT 1;\"]\n    res, _, _ = execute_queries(queries,  db_name, conn)\n    team_id = res[0][0]\n    queries = [f\"UPDATE team_attributes SET buildupplayspeedclass = 'Very Fast' WHERE id = {team_id};\"]\n    _, exec_err, time_err = execute_queries(queries, db_name, conn)\n    assert exec_err == False\n    \n    queries = [f\"UPDATE team_attributes SET buildupplayspeedclass = 'TEST' WHERE id = {team_id};\"]\n    res, exec_err, _ = execute_queries(queries, db_name, conn)\n    assert exec_err == True\n"]}
{"instance_id": 4, "sol_sql": ["CREATE UNIQUE INDEX unique_name_location ON event(event_name, location, event_date) WHERE coalesce(event_name, location) is not null;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_queries = [\n        \"\"\"\n        INSERT INTO event (event_id, event_name, location, event_date)\n        VALUES ('test1', 'test_name', 'test_location', 'test_date');\n        \"\"\"\n    ]\n    execute_queries(check_queries, db_name, conn)\n    \n    check_queries = [\n        \"\"\"\n        insert into event (event_id, event_name, location, event_date)\n\n        values('test2', 'test_name', 'test_location', 'test_date')\n        on conflict (event_name, location, event_date)        \n        where coalesce(event_name, location) is not null \n        do update set\n            event_id = excluded.event_id,\n            event_name = excluded.event_name,\n            location = excluded.location,\n            event_date = excluded.event_date \"\"\"\n    ]\n    res, exec_err, _ = execute_queries(check_queries, db_name, conn)\n    assert exec_err == False\n    queries = [\"SELECT event_id, event_name, location, event_date FROM event WHERE event_name = 'test_name';\"]\n    res, _, _ = execute_queries(queries, db_name, conn)\n    assert len(res) == 1\n    assert res[0][0] == 'test2'\n"]}
{"instance_id": 5, "sol_sql": ["\n    UPDATE transactions_1k \n    SET Amount = 100 \n    FROM ( SELECT customerid, transactionid FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub \n    JOIN customers c ON c.customerid = sub.customerid WHERE transactions_1k.transactionid = sub.transactionid RETURNING transactions_1k.transactionid, c.Segment;\n   "], "test_cases": ["\nimport datetime\n\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    assert pred_query_result == [(947, 'SME'), (988, 'KAM')]"]}
{"instance_id": 6, "sol_sql": ["SELECT users.Id, COUNT(posts.Id) FILTER (WHERE AnswerCount > 0) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 7, "sol_sql": ["DROP TABLE IF EXISTS users CASCADE;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_users_table = execute_queries([\"SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'users';\"], 'codebase_community',conn)[0]\n    assert test_users_table[0][0] == 0, 'Users table should be dropped.'", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_posts_lasteditoruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_1';\"], 'codebase_community',conn)[0] \n    assert test_posts_lasteditoruserid_fkey[0][0] == 0, 'Foreign key posts_lasteditoruserid_fkey should be dropped.'\n    test_posts_owneruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_2';\"], 'codebase_community',conn)[0] \n    assert test_posts_owneruserid_fkey[0][0] == 0, 'Foreign key posts_owneruserid_fkey should be dropped.'\n"]}
{"instance_id": 8, "sol_sql": ["WITH RECURSIVE nodes AS (SELECT u.id, r.ref FROM users u CROSS JOIN LATERAL (VALUES (u.ref1), (u.ref2)) r(ref)), edges AS (SELECT DISTINCT n1.id AS id1, n2.id AS id2 FROM nodes n1 INNER JOIN nodes n2 ON n1.ref = n2.ref), rcte AS (SELECT id1, id2, ARRAY[id1] AS visited FROM edges WHERE id1 = id2 UNION ALL SELECT r.id1, e.id2, r.visited || e.id2 FROM rcte r INNER JOIN edges e ON e.id1 = r.id2 WHERE e.id2 <> ALL(r.visited)), groups AS (SELECT id1 AS id, ARRAY_AGG(DISTINCT id2 ORDER BY id2) AS ids FROM rcte GROUP BY id1) SELECT g.ids, array_agg(DISTINCT u.username) AS usernames, array_agg(DISTINCT u.ref1) AS refs1, CASE WHEN g.ids IS NULL THEN array_agg(DISTINCT a.owner) ELSE array_agg(DISTINCT u.ref2) END AS refs2, array_agg(DISTINCT a.id) AS asset_ids, COUNT(DISTINCT a.id) AS asset_count FROM assets a LEFT JOIN users u ON a.owner IN (u.ref1, u.ref2) LEFT JOIN groups g ON g.id = u.id GROUP BY g.ids;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 9, "sol_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ), CTE2 AS ( SELECT link_to_event, COUNT(budget_id) AS count FROM budget GROUP BY link_to_event) SELECT CTE.link_to_event, CTE.count AS newCount, CTE2.count AS oldCount FROM CTE2 JOIN CTE ON CTE2.link_to_event = CTE.link_to_event WHERE CTE2.count != CTE.count;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 10, "sol_sql": ["INSERT INTO attendance (link_to_event, link_to_member, attend) VALUES ('recEVTik3MlqbvLFi', 'rec280Sk7o31iG0Tx', 1) ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET attend = 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    test_query_result_1 = execute_queries([\"SELECT attend FROM attendance WHERE link_to_event = 'recEVTik3MlqbvLFi' AND link_to_member = 'rec280Sk7o31iG0Tx'\"], 'student_club', conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} rows.'\n    assert test_query_result_1[0][0] == 1, f'Expected attend is updated to 1, but found it is {test_query_result_1[0][0]}'\n    test_query_result_2 = execute_queries([\"SELECT * FROM attendance WHERE attend = 1\"], 'student_club', conn)[0]\n    assert test_query_result_2[0][0] == 'recEVTik3MlqbvLFi', f'Expected recEVTik3MlqbvLFi, but found {test_query_result_2[0][0]}'\n    assert test_query_result_2[0][1] == 'rec280Sk7o31iG0Tx', f'Expected rec280Sk7o31iG0Tx, but found {test_query_result_2[0][1]}'"]}
{"instance_id": 11, "sol_sql": ["\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE varchar(30) \n    USING date::varchar;\n    ", "\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE timestamp \n    USING date::timestamp;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n    \"\"\"\n    SELECT  data_type\n    FROM information_schema.columns\n    WHERE table_name = 'account'\n    AND column_name = 'date';\n    \"\"\"\n    ]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    data_type = res[0][0]\n    assert 'timestamp' in data_type\n    "]}
{"instance_id": 12, "sol_sql": ["SELECT t1.* FROM cards t1 JOIN (SELECT MIN(id) AS id FROM cards GROUP BY artist) t2 ON t1.id = t2.id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    artist_list = sorted([tup[1] for tup in pred_query_result])\n    assert artist_list == ['Daarken', 'Ralph Horsley']"]}
{"instance_id": 13, "sol_sql": ["SELECT *\nFROM transactions_1k\nWHERE CustomerID = 3\n  AND Date = '2012-08-24'\n\nUNION ALL\n\nSELECT *\nFROM transactions_1k\nWHERE CustomerID = 7626\n  AND Date = '2012-08-24'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM transactions_1k\n    WHERE CustomerID = 3\n      AND Date = '2012-08-24'\n  );\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 14, "sol_sql": ["SELECT 'SELECT ' || STRING_AGG('a.' || column_name, ', ') || ' FROM account AS a' FROM information_schema.columns WHERE table_name = 'account' AND table_schema = 'public' AND column_name NOT IN ('account_id', 'date');"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_2 = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_2 = execute_queries(sol_sqls, db_name, conn)\n    pred_sqls_2 = remove_distinct(pred_sqls_2[0][0])\n    sol_sqls_2 = remove_distinct(sol_sqls_2[0][0])\n    result = ex_base(pred_sqls_2, sol_sqls_2, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 15, "sol_sql": ["SELECT *\nFROM\n(\n  SELECT DISTINCT ON (account_id) *\n  FROM\n  (\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        0 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n        AND l.date >= (NOW() - INTERVAL '48 hours')\n      ORDER BY l.date DESC NULLS LAST\n      LIMIT 6\n    )\n    UNION\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        1 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n    )\n  ) t\n  ORDER BY account_id, priority\n) t\nORDER BY priority, loan_date DESC;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": 16, "sol_sql": ["SELECT json_agg(events_array) AS all_events\nFROM (\n  SELECT \n    json_agg(\n      json_build_object(\n        'link_to_member', link_to_member,\n        'link_to_event',  link_to_event\n      )\n    ) AS events_array\n  FROM attendance\n  GROUP BY link_to_event\n) sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def compare_array_of_arrays(arr1, arr2):\n        assert arr1 == arr2, \"The two array-of-array structures do not match.\"\n        return 1\n    \n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = compare_array_of_arrays(pred_query_result[0][0][0], sol_query_result[0][0][0])\n    return result"]}
{"instance_id": 17, "sol_sql": ["SELECT generate_series(\n  EXTRACT(YEAR FROM MIN(date)::timestamptz AT TIME ZONE 'UTC')::int,\n  EXTRACT(YEAR FROM MAX(date)::timestamptz AT TIME ZONE 'UTC')::int\n)::text AS the_year\nFROM loan;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": 18, "sol_sql": ["SELECT *, MAX(amount) OVER (PARTITION BY account_id) \"max\" FROM loan"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 19, "sol_sql": ["CREATE TABLE client_information ( client_id smallserial NOT NULL, first_name character varying(50), last_name character varying(50), full_name character varying(101) GENERATED ALWAYS AS  (CASE WHEN first_name IS NULL THEN last_name WHEN last_name  IS NULL THEN first_name ELSE first_name || ' ' || last_name END) STORED, PRIMARY KEY (client_id) );"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'client_information';\"], db_name, conn)[0]\n    assert test_query_result_1[0][0] == 'client_information' , f\"Table client_information not found in database {test_query_result_1}.\"\n    insert_sql = execute_queries([\"INSERT INTO client_information (first_name, last_name) VALUES ('aaa', 'bbb');\"], db_name, conn);\n    test_query_result_2 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_2 == [('aaa bbb',)], f\"Full name not generated correctly. Found {test_query_result_2}\"\n    update_sql = execute_queries([\"UPDATE client_information SET last_name = 'ccc' WHERE first_name = 'aaa'\"], db_name, conn)\n    test_query_result_3 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_3 == [('aaa ccc',)], f\"Full name not generated correctly. Found {test_query_result_3}\""]}
{"instance_id": 20, "sol_sql": ["WITH ins AS (INSERT INTO cards (uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT (uuid) DO UPDATE SET uuid = NULL WHERE FALSE RETURNING id) SELECT id FROM ins UNION ALL SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' LIMIT 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][0] is not None, 'The returned ID should not be None'\n    test_pred_query_result_1 = execute_queries([\"SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c';\"], db_name, conn)[0]\n    assert pred_query_result[0][0] == test_pred_query_result_1[0][0], f'Expected ID to match, but found {pred_query_result[0][0]} and {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": 21, "sol_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    today = execute_queries([\"SELECT CURRENT_DATE\"], db_name, conn)[0][0][0]\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][4] == 'UPDATE', f'Expected operation_type to be UPDATE, but found {pred_query_result[0][4]}'\n    assert pred_query_result[0][3] == today, f'Expected date is updated to today {today}, but found {pred_query_result[0][3]}'\n    test_query_result_1 = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (22222, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;\"], db_name, conn)[0]\n    assert test_query_result_1[0][4] == 'INSERT', f'Expected operation_type to be INSERT, but found {test_query_result_1[0][4]}'"]}
{"instance_id": 22, "sol_sql": ["SELECT (MAX(releaseDate) - MIN(releaseDate)) + 1 AS cnt, MIN(releaseDate) AS date_min, MAX(releaseDate) AS date_max FROM (SELECT x.*, SUM(i) OVER(ORDER BY releaseDate) AS g FROM (SELECT t.*, CASE WHEN releaseDate > LAG(releaseDate) OVER(ORDER BY releaseDate) + 1 THEN 1 ELSE 0 END AS i FROM sets_releaseInfo t) x) y GROUP BY g;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 23, "sol_sql": ["WITH RECURSIVE path_cte AS (SELECT id, id::text AS Path, id AS FirstID, 1 AS Lvl FROM collection WHERE nextCardId IS NULL UNION ALL SELECT collection.id, collection.id::text || ' --> ' || cte.Path, cte.FirstId, cte.Lvl + 1 FROM collection JOIN path_cte cte ON collection.nextCardId = cte.id) SELECT DISTINCT ON (FirstID) Path FROM path_cte ORDER BY FirstID, Lvl DESC, id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 24, "sol_sql": ["CREATE OR REPLACE FUNCTION what_quarter_is(date_in DATE, start_mon_in INTEGER DEFAULT 1) RETURNS INTEGER LANGUAGE sql AS $$ WITH RECURSIVE qtrs(mq, q, m, c) AS (SELECT 1, 1, start_mon_in, 1 UNION ALL SELECT mq % 3 + 1, CASE WHEN mq % 3 + 1 = 1 THEN q + 1 ELSE q END, CASE WHEN m = 12 THEN 1 ELSE m + 1 END, c + 1 FROM qtrs WHERE c < 12) SELECT q FROM qtrs WHERE m = EXTRACT(MONTH FROM date_in); $$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT proname, proargnames, prorettype::regtype, prosrc FROM pg_proc WHERE proname = 'what_quarter_is';\"], db_name, conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} row(s).'\n    test_query_result_2 = execute_queries([\"SELECT what_quarter_is('2024-01-01', 4)\"], db_name, conn)[0]\n    assert test_query_result_2[0][0] == 4, f'Expected 4, but found {test_query_result_2[0][0]}'\n    test_query_result_3 = execute_queries([\"SELECT what_quarter_is('2023-07-01', 2)\"], db_name, conn)[0]\n    assert test_query_result_3[0][0] == 2, f'Expected 2, but found {test_query_result_3[0][0]}.'"]}
{"instance_id": 25, "sol_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table, a.attname as base_col, (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table, UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col, pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey) WHERE c.confrelid = (select oid from pg_class where relname = 'users') AND c.confrelid!=c.conrelid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 26, "sol_sql": ["SELECT bank, first_value(bank) over (partition by account_id order by date rows between current row and unbounded following) as next_bank FROM trans WHERE bank is not null ORDER BY account_id, date;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 27, "sol_sql": ["SELECT t1.team_api_id, t1.team_short_name, t2.buildUpPlaySpeed FROM Team t1 INNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 28, "sol_sql": ["WITH years AS ( SELECT date_trunc('year', date) as year, COUNT(*) as count FROM trans GROUP BY 1 UNION ALL SELECT date_trunc('year', date) as year, COUNT(*) as count FROM loan GROUP BY 1 ) SELECT year, SUM(count) as count FROM years GROUP BY year ORDER BY year;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 29, "sol_sql": ["WITH gen_transactions AS (SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER))), shuffle AS (SELECT CustomerID, Amount, row_number() OVER (ORDER BY random()) AS rn FROM gen_transactions) SELECT CustomerID, Amount FROM shuffle WHERE rn <= 5 ORDER BY rn;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 5, f'Expected 5 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(set(row[0] for row in pred_query_result)) == 5, 'All CustomerIDs should be unique'\n    "]}
{"instance_id": 30, "sol_sql": ["\nINSERT INTO card_information(price)\nSELECT jsonb_agg(s.elements)\nFROM (\n  SELECT jsonb_array_elements(price) FROM card_information\n) AS s(elements);\n\nSELECT * FROM card_information;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    assert isinstance(concatenated_json, list), f'Expected result to be a list, but found {type(concatenated_json)}'   \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_json_length = 9\n    assert len(concatenated_json) == expected_json_length, f'Expected {expected_json_length} elements, but found {len(concatenated_json)} elements'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_values = [{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5}, {\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5}, {\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}]\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'\n    "]}
{"instance_id": 31, "sol_sql": ["\nSELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency\nFROM (\n    SELECT DISTINCT ON (t.k_symbol) \n           t.k_symbol, t.operation, t.amount, t.balance, t.account_id, t.date\n    FROM trans t\n    WHERE t.account_id = 1\n    AND t.type = 'PRIJEM'\n    ORDER BY t.k_symbol, t.date\n) t\nINNER JOIN account a ON t.account_id = a.account_id LIMIT 100\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_UROK = [i for i, row in enumerate(pred_query_result) if row[0] == 'UROK']\n    row_n = row_with_UROK[0]\n    assert pred_query_result[row_n][1] is None, f'Expected operation to be NULL, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 19, f'Expected amount to be 19, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 17298, f'Expected balance to be 17298, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_NULL = [i for i, row in enumerate(pred_query_result) if row[0] is None]\n    row_n = row_with_NULL[0]\n    assert pred_query_result[row_n][1] == 'VKLAD', f'Expected operation to be VKLAD, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 1000, f'Expected amount to be 1000, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 1000, f'Expected balance to be 1000, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    "]}
{"instance_id": 32, "sol_sql": ["\nWITH cte AS (\n    SELECT user_id, \n           TO_DATE(purchase_date || '-01','YYYY-MM-DD') AS date_as_date\n    FROM purchase\n), islands AS ( \n    SELECT *, \n           CASE WHEN LAG(date_as_date) OVER(PARTITION BY user_id ORDER BY date_as_date) + INTERVAL '1 month' <> date_as_date\n                THEN 1 ELSE 0 \n           END AS new_partition\n    FROM cte\n), partitioned_islands AS (\n    SELECT user_id, \n           SUM(new_partition) OVER(PARTITION BY user_id ORDER BY date_as_date) AS partitions\n    FROM islands\n), count_per_island AS (\n    SELECT COUNT(*) AS num_consecutive_dates\n    FROM partitioned_islands\n    GROUP BY user_id, partitions\n    ORDER BY ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY COUNT(*) DESC)\n    FETCH FIRST 1 ROWS WITH TIES\n)\nSELECT num_consecutive_dates AS streakLength, \n       COUNT(*) AS numOfOccurrences  \nFROM count_per_island\nGROUP BY streakLength\nORDER BY streakLength DESC\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 5, f'Expected longest streak length to be 5, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == 1, f'Expected 1 user with longest streak of 5 months, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][0] == 4, f'Expected longest streak length to be 4, but found {pred_query_result[1][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == 2, f'Expected 2 users with longest streak of 4 months, but found {pred_query_result[1][1]}'\n    "]}
{"instance_id": 33, "sol_sql": ["\nWITH tab_with_cardid AS (\n    SELECT *, \n           REGEXP_REPLACE(cardid, '([^-]+)-[^-]+-(.*)', '\\1-\\2') AS pure_cardid\n    FROM card_info\n),\nranked_visits AS (\n    SELECT *, \n           ROW_NUMBER() OVER (PARTITION BY pure_cardid ORDER BY type) AS rn\n    FROM tab_with_cardid\n)\nSELECT cardid, pure_cardid, type\nFROM ranked_visits\nWHERE rn = 1\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == '1234-HIJK', f'Expected ci_ku to be 1234-HIJK, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][2] == 'A', f'Expected l1m_visits to be A, but found {pred_query_result[0][2]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == '56457-DF-GH-TC', f'Expected ci_ku to be 56457-DF-GH-TC, but found {pred_query_result[1][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][2] == 'D', f'Expected l1m_visits to be D, but found {pred_query_result[1][2]}'\n"]}
{"instance_id": 34, "sol_sql": ["SELECT player_api_id, date, overall_rating FROM Player_Attributes ORDER BY ROW_NUMBER() OVER(PARTITION BY player_api_id ORDER BY date DESC) FETCH FIRST 1 ROWS WITH TIES;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 35, "sol_sql": ["CREATE OR REPLACE FUNCTION get_user_ages() RETURNS setof numeric AS $BODY$ DECLARE curr_age  text; BEGIN FOR curr_age IN SELECT Age FROM users LOOP BEGIN RETURN NEXT curr_age::numeric; EXCEPTION WHEN OTHERS THEN NULL; END; END LOOP; END $BODY$  LANGUAGE plpgsql; SELECT * FROM get_user_ages();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT count(*) FROM users;\"], db_name, conn)\n    ori_count = res[0][0]\n    res, _, _ = execute_queries([\"SELECT count(*) FROM get_user_ages();\"], db_name, conn)\n    next_count = res[0][0]\n    assert next_count ==  (ori_count-1), f'Expected 40325 row in get_user_ages table, got {next_count}'\n    res,_, _ = execute_queries([\"SELECT count(get_user_ages) FROM get_user_ages() where get_user_ages = 31 GROUP BY get_user_ages order by get_user_ages;\"], db_name,conn)\n    init_res = res[0][0]\n    res, _, _ = execute_queries([\"select count(age) from users where age = '31' group by age order by age ;\"], db_name,conn)\n    other_res = res[0][0]\n    assert init_res == other_res, f'Expected same result, got {init_res} and {other_res}'\n    \n"]}
{"instance_id": 36, "sol_sql": ["CREATE OR REPLACE FUNCTION profileTrigger() RETURNS TRIGGER AS $profile_table$ begin insert into profiles (id, CreationDate, WebsiteUrl) select new.Id, new.CreationDate, left(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), strpos(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), '.')-1);return new; end; $profile_table$ LANGUAGE plpgsql; CREATE TRIGGER profile_table AFTER INSERT ON users FOR EACH ROW EXECUTE PROCEDURE profileTrigger();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_sql = [\"INSERT INTO users VALUES (341111,185,'2010-07-19 19:11:11','Christopher D. Long','2014-09-13 00:02:35','http://angrystatistician.blogspot.com','Versailles, KY','<p>Consulting analyst for the San Diego Padres, Houston Rockets.</p><p>Twitter:</a></p><p>LinkedIn/p>',27,23,0,509455,NULL,'http://i.stack.imgur.com/km1pr.jpg')\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([\"SELECT * FROM profiles LIMIT 1;\"], db_name,conn)\n    res_id, res_CreationDate, res_WebsiteUrl = res[0][0], res[0][1], res[0][2]\n    assert len(res) == 1, f\"Expected 1 row in profiles table, got {len(res)}\"\n    assert res_id == '341111', f\"Expected id to be '341111', got {res_id}\"\n    assert res_WebsiteUrl == 'angrystatistician', f\"Expected WebsiteUrl to be 'angrystatistician', got {res_WebsiteUrl}\"\n    \n"]}
{"instance_id": 37, "sol_sql": ["DROP INDEX IF EXISTS idx_trans_account_bank_type", "CREATE INDEX idx_trans_account_bank_type ON trans (account_id, bank, type);", "ANALYZE trans;", "SELECT trans_id, account_id, date, type, amount FROM trans WHERE account_id IN (SELECT account_id FROM account WHERE district_id = 18) AND bank = 'AB' AND type IN ('PRIJEM', 'VYDAJ')"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 38, "sol_sql": ["SELECT * FROM cards WHERE  3 = (CASE WHEN availability = 'paper' THEN 1 ELSE 0 END) + (CASE WHEN bordercolor = 'black' THEN 1 ELSE 0 END) + (CASE WHEN rarity = 'uncommon' THEN 1 ELSE 0 END) + (CASE WHEN types = 'Creature' THEN 1 ELSE 0 END);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 39, "sol_sql": ["WITH j AS (INSERT INTO event (event_id, event_name, event_date, type, notes, location, status) VALUES ('recAlAwtBZ0Fqbr5K', 'Annual Gala', '2023-12-15T19:00:00', 'Social', 'Annual Gala for club members', 'Grand Ballroom', 'Open') ON CONFLICT (event_id) DO UPDATE SET event_id = event.event_id RETURNING xmax = 0 AS inserted, *) INSERT INTO failure (event, member) SELECT event_id, 'rec280Sk7o31iG0Tx' FROM j WHERE NOT inserted RETURNING *;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1, _, _ = execute_queries([\"SELECT event FROM failure;\"], db_name, conn)\n    pred_query_result_2, _, _  = execute_queries([\"SELECT member FROM failure;\"], db_name, conn)\n    assert len(pred_query_result_1) == 1, f'Expected 1 rows, but found {len(pred_query_result_1)} rows' \n    assert len(pred_query_result_2) == 1, f'Expected 1 rows, but found {len(pred_query_result_2)} rows'\n    assert pred_query_result_1[0][0] == 'recAlAwtBZ0Fqbr5K', f'Expected event ID to match, but found {pred_query_result_1[0][0]}'\n    assert pred_query_result_2[0][0] == 'rec280Sk7o31iG0Tx', f'Expected member ID to match, but found {pred_query_result_2[0][0]}'\n    "]}
{"instance_id": 40, "sol_sql": ["CREATE OR REPLACE FUNCTION log_player_name_changes() RETURNS trigger AS $BODY$ BEGIN IF NEW.player_name <> OLD.player_name THEN INSERT INTO player_audits(player_id, old_player_name, changed_on) VALUES(OLD.id, OLD.player_name, now()); END IF; RETURN NEW; END; $BODY$ LANGUAGE plpgsql;CREATE TRIGGER tr_change_playername AFTER UPDATE OF player_name ON player FOR EACH ROW EXECUTE PROCEDURE log_player_name_changes();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([f\"SELECT player_name FROM player WHERE id = 1;\"], db_name,conn)\n    old_p_name = res[0][0]\n    check_sql = [f\"UPDATE player SET player_name = {old_p_name} WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT * FROM player_audits\"], db_name, conn)\n    assert len(res) == 0, f\"The trigger conditioning does not work.\"\n    \n    check_sql = [f\"UPDATE player SET player_name = 'James Higginsons' WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT old_player_name FROM player_audits LIMIT 1\"], db_name,conn)\n    old_name = res[0][0]\n    assert old_name == 'Aaron Appindangoye', f\"The trigger does not work.\"\n"]}
{"instance_id": 41, "sol_sql": ["\nSELECT\n    ea.MemberID,\n    MAX(CASE WHEN ea.EventType = 'Game' THEN ea.AttendanceDate END) AS Latest_Game_Date,\n    SUM(CASE WHEN ea.EventType = 'Game' THEN 1 ELSE 0 END) AS Total_Game_Attendance,\n    MAX(CASE WHEN ea.EventType = 'Workshop' THEN ea.AttendanceDate END) AS Latest_Workshop_Date,\n    SUM(CASE WHEN ea.EventType = 'Workshop' THEN 1 ELSE 0 END) AS Total_Workshop_Attendance,\n    COUNT(*) AS Total_Attendance\nFROM (\n    SELECT MemberID, EventType, AttendanceDate\n    FROM event_attendance\n    WHERE EventType IN ('Game', 'Workshop')\n) ea\nGROUP BY ea.MemberID\nORDER BY ea.MemberID;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n\n    ", "\nimport datetime\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 1, f'Expected MemberID 1 in the first row, but found {pred_query_result[0][0]}'\n    pred_game_date = pred_query_result[0][1]\n    pred_game_date_str = pred_game_date.strftime('%Y-%m-%d')\n    expected_date_str = '2023-02-20'\n    assert pred_game_date_str == expected_date_str, f'Expected Game_AttendanceDate 2023-02-20 for MemberID 1, but found {pred_game_date_str}'\n    assert pred_query_result[1][4] == 1, f'Expected Workshop_Attendances 1 for MemberID 2, but found {pred_query_result[1][4]}'\n\n    assert pred_query_result[0][5] == 6, f'Expected Total_Attendances 6 for MemberID 1, but found {pred_query_result[0][5]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 42, "sol_sql": ["\nSELECT t.userid, t.tag\nFROM   preference_tag t\nWHERE  NOT EXISTS (\n   SELECT FROM unnest('{%friend%, %cat%}'::text[]) AS p(pattern)\n   WHERE  NOT EXISTS (\n      SELECT FROM unnest(t.tag) AS a(elem)\n      WHERE  a.elem LIKE p.pattern\n      )\n   )\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 1, f'Expected id to be 1, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][1] == ['wildcat', 'potato', 'alices-friend'], f\"Expected value to be ['wildcat', 'potato', 'alices-friend'], but found {pred_query_result[2][1]}\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][0] == 4, f'Expected id to be 4, but found {pred_query_result[2][0]}'\n"]}
{"instance_id": 43, "sol_sql": ["SELECT * FROM account_info WHERE condition::jsonb @> '[ { \"conditions\": { \"rootcompanyid\": { \"$in\": [5] } } } ]'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} row(s).'\n    assert pred_query_result[0][0] == 1, f'Expected the account_id is 1, but found {pred_query_result[0][0]}'\n    assert pred_query_result[1][0] == 3, f'Expected the account_id is 3, but found {pred_query_result[1][0]}'"]}
{"instance_id": 44, "sol_sql": ["CREATE UNIQUE INDEX idx_hero_power_active ON hero_power (hero_id, power_id) WHERE active;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    try:\n        insert_sql_1 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, TRUE);'], db_name, conn)[0];\n        assert False, 'Inserting duplicate id should have raised an error'\n    except Exception as err:\n        assert 'duplicate' in str(err), f'Expected duplicate key error, but found {err}.'\n    check_insertion_result_1 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_1[0][0] == 1, 'Expected only 1 entry for hero_id 1 and power_id 1.'\n    insert_sql_2 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_2 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_2[0][0] == 2, 'Expected two entries for hero_id 1 and power_id 1, one active and one inactive.'\n    insert_sql_3 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_3 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_3[0][0] == 3, 'Expected three entries for hero_id 1 and power_id 1, one active and two inactive.'"]}
{"instance_id": 45, "sol_sql": ["SELECT DISTINCT o1.user_id, o1.email FROM orders o1 WHERE (o1.segment = 'luxury' AND o1.destination = 'New York') OR (o1.segment = 'luxury' AND o1.destination = 'London') OR (o1.segment = 'basic' AND o1.destination = 'New York' AND o1.user_id IN (SELECT o2.user_id FROM orders o2 WHERE o2.segment = 'basic' AND o2.destination = 'New York' GROUP BY o2.user_id HAVING SUM(o2.revenue) > 2000)) EXCEPT SELECT DISTINCT o3.user_id, o3.email FROM orders o3 WHERE o3.destination = 'Miami'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 46, "sol_sql": ["SELECT version FROM cars ORDER BY CAST(SUBSTRING(version FROM '^[0-9]+') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.([0-9]+)') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.[0-9]+-([0-9]+)') AS INTEGER) DESC, CASE WHEN version LIKE '%-%' THEN SUBSTRING(version FROM '-(.*)') ELSE '' END DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 47, "sol_sql": ["WITH select_patient AS ( SELECT patient_id FROM prescriptions WHERE medication_id = 1 ) SELECT patient_id, array_agg(DISTINCT medication_id ORDER BY medication_id) AS medications FROM prescriptions WHERE patient_id in (select patient_id from select_patient) GROUP BY patient_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 48, "sol_sql": ["SELECT d.driverId, COALESCE(SUM(r.points), 0) AS total_points FROM drivers d LEFT JOIN results r ON d.driverId = r.driverId GROUP BY d.driverId"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 49, "sol_sql": ["SELECT \n    sqA.alignment_count     AS total_by_alignment,\n    A.alignment             AS alignment,\n    R.race                  AS race,\n    sqAR.alignment_race_count AS count_by_alignment_race\nFROM\n    (\n       SELECT\n           alignment_id,\n           COUNT(*) AS alignment_count\n       FROM superhero\n       GROUP BY alignment_id\n    ) sqA\n\n    INNER JOIN\n    (\n       SELECT\n           alignment_id,\n           race_id,\n           COUNT(*) AS alignment_race_count\n       FROM superhero\n       GROUP BY alignment_id, race_id\n    ) sqAR ON sqA.alignment_id = sqAR.alignment_id\n\n    INNER JOIN alignment A ON sqA.alignment_id = A.id\n\n    INNER JOIN race R ON sqAR.race_id = R.id\nORDER BY\n    A.alignment,\n    R.race;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 50, "sol_sql": ["select driverId, points, array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred = execute_queries(pred_sqls,db_name,conn)\n    sol = execute_queries(sol_sqls,db_name,conn)\n    assert pred == sol\n    return pred == sol"]}
{"instance_id": 51, "sol_sql": ["WITH cte AS (\n    SELECT\n        p.*,\n        CEIL( (ROW_NUMBER() OVER (\n                 PARTITION BY raceId \n                 ORDER BY time::time\n               ) + 1 ) / 2.0\n        ) AS rn\n    FROM pitStops p\n    WHERE raceId = 842\n),\ncte2 AS (\n    SELECT\n        rn,\n        MIN(time::time) AS starttime,\n        MAX(time::time) AS endtime,\n        CAST(MAX(time::time) - MIN(time::time) AS time) AS total_pause\n    FROM cte\n    GROUP BY rn\n)\nSELECT\n    MAX(endtime) AS endtime,\n    MIN(starttime) AS starttime,\n    CAST(SUM(total_pause) AS time) AS total_pit_stop_duration\nFROM cte2;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 52, "sol_sql": ["SELECT json_object_agg(label, groupedMolecules) AS molecules_by_label\nFROM (\n  SELECT label,\n         json_agg(\n           json_build_object(\n             'molecule_id', molecule.molecule_id,\n             'atoms', (\n               SELECT json_agg(\n                 json_build_object(\n                   'atom_id', atom.atom_id,\n                   'element', atom.element\n                 )\n               )\n               FROM atom\n               WHERE atom.molecule_id = molecule.molecule_id\n             ),\n             'bonds', (\n               SELECT json_agg(\n                 json_build_object(\n                   'bond_id', bond.bond_id,\n                   'bond_type', bond.bond_type\n                 )\n               )\n               FROM bond\n               WHERE bond.molecule_id = molecule.molecule_id\n             )\n           )\n         ) AS groupedMolecules\n  FROM molecule\n  GROUP BY label\n) AS sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def json_matches_gold(generated_json, gold_json):\n        # If either object is a string, parse it as JSON\n        if isinstance(generated_json, str):\n            generated_json = json.loads(generated_json)\n        if isinstance(gold_json, str):\n            gold_json = json.loads(gold_json)\n\n        # Return whether the Python structures match exactly\n        return generated_json == gold_json\n    \n    sol = execute_queries(sol_sqls,db_name,conn)\n    pred = execute_queries(pred_sqls,db_name,conn)\n    assert json_matches_gold(sol[0], pred[0])\n    return json_matches_gold(sol[0], pred[0])"]}
{"instance_id": 53, "sol_sql": ["SELECT\n    molecule_id,\n    COUNT(DISTINCT CASE WHEN element = 'na' THEN 1 END)         AS na_atoms,\n    COUNT(DISTINCT CASE WHEN element IN ('c', 'cl') THEN molecule_id END) AS c_atoms\nFROM atom\nGROUP BY molecule_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 54, "sol_sql": ["SELECT date_trunc('hour', \"date\"::timestamp), home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY date_trunc('hour', \"date\"::timestamp), home_team_api_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 55, "sol_sql": ["SELECT c.id  FROM clients c INNER JOIN clients_to_groups ctg ON c.id = ctg.client_id AND ctg.group_id IN (1,3,5,6) GROUP BY c.id HAVING  COUNT(CASE WHEN ctg.group_id IN (1,3) THEN 1 END) > 0 AND COUNT(CASE WHEN ctg.group_id IN (5,6) THEN 1 END) > 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 56, "sol_sql": ["SELECT MIN(transaction_date) AS date, club_name, SUM(amount) AS amount FROM (SELECT *, SUM(flag) OVER (PARTITION BY club_name ORDER BY transaction_date) AS grp FROM (SELECT *, COALESCE(SIGN(amount) <> LAG(SIGN(amount)) OVER (PARTITION BY club_name ORDER BY transaction_date), true)::int AS flag FROM club_transactions) t) t GROUP BY club_name, grp ORDER BY club_name, date;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 57, "sol_sql": ["WITH RECURSIVE cte(id, p, js) AS (SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m1.id_module, 'id_parent_module', m1.id_parent_module, 'module_code', m1.module_code, 'name_module', m1.name_module, 'desc_module', m1.desc_module) jsn FROM modules m JOIN modules m1 ON m1.id_parent_module = m.id_module WHERE NOT EXISTS (SELECT 1 FROM modules m2 WHERE m2.id_parent_module = m1.id_module)) t GROUP BY t.id_module, t.id_parent_module UNION ALL SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js) jsn FROM modules m JOIN cte c ON m.id_module = c.p JOIN modules m2 ON m2.id_module = c.id) t GROUP BY t.id_module, t.id_parent_module) SELECT jsonb_pretty(t.result::jsonb) FROM (SELECT json_agg(json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js)) result FROM cte c JOIN modules m2 ON c.id = m2.id_module WHERE c.p IS NULL) t"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 58, "sol_sql": ["SELECT atom_id,(ARRAY_AGG(element ORDER BY edit_id DESC) FILTER (WHERE element IS NOT NULL))[1] AS element,(ARRAY_AGG(molecule_id ORDER BY edit_id DESC)FILTER (WHERE molecule_id IS NOT NULL))[1] AS molecule_id FROM atom_edits GROUP BY atom_id"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 59, "sol_sql": ["INSERT INTO customers (customerid, segment, currency)\nSELECT DISTINCT ON (customerid, segment, currency) \n       customerid, \n       segment, \n       currency\nFROM (\n    VALUES\n       (3, 'SME', 'EUR'),\n       (1, 'KAM', 'CZK'),\n       (3, 'SME', 'EUR')\n) AS v(customerid, segment, currency)\nON CONFLICT (customerid, segment, currency)\nDO UPDATE \n   SET currency = customers.currency\nRETURNING CustomerID"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name,conn)[0] \n    assert test_pred_query_result_1 == [(1,), (3,)]"]}
{"instance_id": 60, "sol_sql": ["\nUPDATE disp\nSET addresses = '[{\"PostCode\": null}]'\nWHERE jsonb_typeof(addresses) <> 'array'\n   OR addresses = '[]';\n\nSELECT \n    c.client_id, \n    c.gender, \n    d.disp_id, \n    addr ->> 'PostCode' AS PostCode\nFROM client c\nFULL JOIN disp d ON c.client_id = d.client_id,\njsonb_array_elements(d.addresses) AS addr\nWHERE c.client_id = 12345;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name,conn)[0] \n    assert test_pred_query_result_1 == []"]}
{"instance_id": 61, "sol_sql": ["-- Correct / Solution SQL\nINSERT INTO loan (\n  account_id,\n  date,\n  amount,\n  duration,\n  payments,\n  status\n)\nVALUES (\n  2,\n  '1996-04-29',\n  30276,\n  12,\n  2523.0,\n  'B'\n)\nON CONFLICT (account_id, date)\nDO UPDATE\n   SET amount = EXCLUDED.amount + 1000;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    \"\"\"\n    This function tests whether the given pred_sqls can fulfill the requirement:\n      \"The 'loan_id' should only increment when a new record is inserted.\"\n    Specifically, if (account_id, date) already exists, we expect to UPDATE instead\n    of inserting a new row or incrementing the loan_id.\n    \n    - We create a fresh 'loan' table with a unique constraint on (account_id, date).\n    - Insert one baseline record that matches the sol_sqls initial amount (30276).\n    - Run the pred_sqls (which presumably does an UPSERT on the same (account_id, date)).\n    - Check if we still have exactly one row with the updated amount (30276 + 1000 = 31276).\n    - If there's more than one row or the amount is not updated to 31276, we fail.\n    \"\"\"\n\n    # 1) Drop the table if it exists, to start fresh\n    drop_sql = [\"DROP TABLE IF EXISTS loan CASCADE;\"]\n    execute_queries(drop_sql, db_name, conn)\n\n    # 2) Create a fresh 'loan' table with a unique constraint on (account_id, date)\n    create_sql = [\"\"\"\n        CREATE TABLE loan (\n            loan_id   SERIAL PRIMARY KEY,\n            account_id INT NOT NULL,\n            date       DATE NOT NULL,\n            amount     INT NOT NULL,\n            duration   INT NOT NULL,\n            payments   DOUBLE PRECISION NOT NULL,\n            status     TEXT NOT NULL,\n            UNIQUE(account_id, date)\n        );\n    \"\"\"]\n    execute_queries(create_sql, db_name, conn)\n\n    # 3) Insert an initial record that we expect to update later\n    #    We use the same baseline amount as sol_sqls (30276) so the final will be 31276.\n    init_insert_sql = [\"\"\"\n        INSERT INTO loan (account_id, date, amount, duration, payments, status)\n        VALUES (2, '1996-04-29', 30276, 12, 2500.0, 'X');\n    \"\"\"]\n    execute_queries(init_insert_sql, db_name, conn)\n\n    # 4) Execute the pred_sqls (the user's upsert logic)\n    execute_queries(pred_sqls, db_name, conn)\n\n    # 5) Check how many rows we have for (account_id=2, date='1996-04-29') \n    check_sql = [\"SELECT loan_id, account_id, date, amount FROM loan WHERE account_id=2 AND date='1996-04-29';\"]\n    rows = execute_queries(check_sql, db_name, conn)[0]\n\n    # 6) Evaluate the result\n    assert len(rows) == 1, (\n        f\"Expected only 1 row for (account_id=2, date='1996-04-29'), but found {len(rows)}. \"\n        \"This likely means the upsert inserted a new row instead of updating.\"\n    )\n\n    loan_id_val, acct_val, date_val, amount_val = rows[0]\n\n    # Amount should be updated from 30276 to 31276 (30276 + 1000).\n    expected_amount = 30276 + 1000\n    assert amount_val == expected_amount, (\n        f\"Expected amount={expected_amount} after update, but got {amount_val}. \"\n        \"This likely means the existing row was not updated correctly (or the conflict logic is wrong).\"\n    )"]}
{"instance_id": 62, "sol_sql": ["DELETE FROM cards WHERE (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM norm1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL UNION ALL SELECT uuid, setCode, rarity, manaCost FROM norm2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = perform_query_on_postgresql_databases('SELECT COUNT(*) FROM cards WHERE (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM norm1 UNION SELECT uuid, setCode, rarity, manaCost FROM norm2);', db_name)[0]\n    assert test_pred_query_result_2[0][0] == 0, f'Expected count to match, but found {pred_query_result[0][0]} and {test_pred_query_result_2[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_5 = perform_query_on_postgresql_databases('SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 2 != 0 AND id % 3 != 0;', db_name)[0]\n    assert len(test_pred_query_result_5) == 0, f'Expected 0 rows, but found {len(test_pred_query_result_5)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_6 = perform_query_on_postgresql_databases('SELECT COUNT(*) FROM cards;', db_name)[0]\n    assert test_pred_query_result_6[0][0] == 32993, f'Expected to find 32993 rows, but found  {test_pred_query_result_6[0][0]} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    #result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    #assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 63, "sol_sql": ["CREATE OR REPLACE FUNCTION f_gap_fill_update(\n    _tbl regclass, \n    _id text, \n    _row_num text, \n    OUT nullable_columns int, \n    OUT updated_rows int\n) LANGUAGE plpgsql AS $func$\nDECLARE \n    _pk text := quote_ident(_row_num); \n    _sql text;\nBEGIN\n    SELECT INTO _sql, nullable_columns concat_ws(E'\n',\n        'UPDATE ' || _tbl || ' t',\n        'SET (' || string_agg(quote_ident(a.attname), ', ') || ') = ',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')',\n        'FROM (',\n        '   SELECT ' || _pk,\n        '        , ' || string_agg(\n                     format(\n                         'COALESCE(%1$I, MAX(%1$I) OVER (PARTITION BY %2$s ORDER BY %3$s ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)) AS %1$I',\n                         a.attname, _id, _pk\n                     ), \n                     ', '\n                 ),\n        '   FROM ' || _tbl,\n        '   ) u',\n        format('WHERE t.%1$s = u.%1$s', _pk),\n        'AND (' || string_agg('t.' || quote_ident(a.attname), ', ') || ') IS DISTINCT FROM',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')'\n    ), \n    count(*)\n    FROM (\n        SELECT a.attname \n        FROM pg_attribute a \n        WHERE a.attrelid = _tbl \n          AND a.attnum > 0 \n          AND NOT a.attisdropped \n          AND NOT a.attnotnull \n        ORDER BY a.attnum\n    ) a;\n\n    RAISE NOTICE 'Generated SQL: %', _sql;\n\n    IF nullable_columns = 0 THEN \n        RAISE EXCEPTION 'No nullable columns found in table >>%<<', _tbl; \n    ELSIF _sql IS NULL THEN \n        RAISE EXCEPTION 'Generated SQL is NULL. Check table or column logic!';\n    END IF;\n\n    EXECUTE _sql;\n\n    GET DIAGNOSTICS updated_rows = ROW_COUNT; \nEND $func$;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    def execute_sqls(sql_list):\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                try:\n                    cur.execute(sql)\n                    conn.commit()\n                except Exception as e:\n                    conn.rollback()\n                    return str(e)\n        return \"success\"\n\n    def validate_forward_fill(limit=10):\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SELECT t1.trans_id, t1.account_id, t1.amount AS current_amount, t2.amount AS previous_amount\n                FROM trans t1\n                LEFT JOIN trans t2\n                  ON t1.account_id = t2.account_id\n                 AND t1.date > t2.date\n                WHERE t1.amount IS NULL AND t2.amount IS NOT NULL\n                ORDER BY t1.date\n                LIMIT %s;\n            \"\"\", (limit,))\n            rows = cur.fetchall()\n            if rows:\n                return False\n            return True\n\n    def debug_generated_sql():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SET client_min_messages TO NOTICE;\n                DO $$\n                BEGIN\n                    PERFORM f_gap_fill_update('trans', 'account_id', 'trans_id');\n                END $$;\n            \"\"\")\n            cur.execute(\"RESET client_min_messages;\") \n\n    def reset_trans_table():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                UPDATE trans\n                SET amount = CASE\n                    WHEN trans_id = 1 THEN 1000\n                    WHEN trans_id IN (5, 6, 7, 8, 9, 10, 11, 12) THEN NULL\n                    ELSE amount\n                END;\n            \"\"\")\n            conn.commit()\n\n    reset_trans_table()\n    pred_result = execute_sqls(pred_sqls)\n    assert pred_result == \"success\"\n\n    debug_generated_sql()\n    assert validate_forward_fill(), \"Validate forward fill function logic.\"\n\n    return 1"]}
{"instance_id": 64, "sol_sql": ["UPDATE card c\nSET disp_id =\n    CASE \n        WHEN c.disp_id = sub.disp_id THEN 1\n        WHEN c.disp_id < sub.disp_id THEN c.disp_id + 1\n        ELSE c.disp_id\n    END\nFROM (\n    SELECT disp_id, type\n    FROM card\n    WHERE disp_id = 41\n) sub\nWHERE c.type = sub.type\n  AND c.disp_id <= sub.disp_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the predicted SQLs\n    _, pred_exec_err, _ = execute_queries(pred_sqls, db_name, conn)\n    assert pred_exec_err == False, \"Error in executing predicted SQLs\"\n\n    # Validate the change\n    query = \"SELECT disp_id FROM card WHERE card_id = 1 AND type = 'gold';\"\n    res, _, _ = execute_queries([query], db_name, conn)\n    assert len(res) == 1, \"No matching record found for card_id = 1 and type = 'gold'\"\n    assert res[0][0] == 10, f\"Expected disp_id to be 10, but got {res[0][0]}\"\n\n    return 1"]}
{"instance_id": 65, "sol_sql": ["\n  CREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date)\n    RETURNS SETOF date\n    LANGUAGE SQL\n    IMMUTABLE\n    PARALLEL SAFE\n    ROWS 10\n  AS\n  $function$\n    SELECT generate_series(\n      date_trunc('month', a),\n      date_trunc('month', b),\n      '1 month'\n    );\n  $function$;\n  ", "\n  EXPLAIN VERBOSE\n  SELECT generate_series_monthly('2024-01-01', '2024-05-01');\n  "], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    \"\"\"\n    Checks if pred_sqls (the tested scenario) produces the same \"rows=10\" estimate\n    as sol_sqls (the correct solution), using assert statements.\n\n    :param pred_sqls: list[str] - SQL statements to be tested\n    :param sol_sqls: list[str] - SQL statements that represent the known correct solution\n    :param db_name: str - name of the database to connect to (if needed)\n    :param conn: psycopg2.extensions.connection - an established DB connection\n    :return: None - the function will raise AssertionError if the conditions are not met\n    \"\"\"\n    def run_sql_and_get_explain_rows(sql_list):\n        \"\"\"\n        Executes a list of SQL statements and returns the output rows of the last\n        EXPLAIN statement (if any).\n        \"\"\"\n        rows_output = []\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                cur.execute(sql)\n                # If it is an EXPLAIN statement, fetch and store its result\n                if sql.strip().upper().startswith(\"EXPLAIN\"):\n                    rows_output = cur.fetchall()\n        return rows_output\n\n    # Run the tested SQL and check for \"rows=10\"\n    pred_explain_rows = run_sql_and_get_explain_rows(pred_sqls)\n    pred_has_rows10 = any(\"rows=10\" in str(row) for row in pred_explain_rows)\n\n    assert pred_has_rows10, (\n        \"Expected to find 'rows=10' in the tested scenario's EXPLAIN output, but it was not found.\"\n    )\n\n    return 1"]}
{"instance_id": 66, "sol_sql": ["WITH cte AS (\n    SELECT\n        m.*,\n        SUM(\n          CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END\n        ) OVER (ORDER BY m.date) AS grp\n    FROM match AS m\n),\naggregates AS (\n    SELECT\n        grp,\n        MAX(date) FILTER (WHERE home_team_goal = away_team_goal) AS draw_date,\n        1 AS invoiced,\n        SUM(home_team_goal + away_team_goal) AS total_goals\n    FROM cte\n    GROUP BY grp\n)\nSELECT \n    grp,\n    draw_date AS date,\n    invoiced,\n    total_goals AS amount\nFROM aggregates\nWHERE draw_date IS NOT NULL\nORDER BY grp;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 67, "sol_sql": ["WITH last_per_station AS (\n  SELECT\n    t.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY customerid, gasstationid\n      ORDER BY transactionid DESC\n    ) AS rn\n  FROM transactions_1k t\n),\nDataSource AS (\n  SELECT\n    lps.*,\n    CASE WHEN amount < 10 THEN transactionid END AS fail_id,\n    CASE WHEN amount >= 10 THEN transactionid END AS pass_id\n  FROM last_per_station lps\n  WHERE rn = 1\n),\nCalculated AS (\n  SELECT\n    ds.*,\n    MIN(fail_id) OVER (PARTITION BY customerid) AS earliest_fail_id,\n    MAX(pass_id) OVER (PARTITION BY customerid) AS last_pass_id\n  FROM DataSource ds\n)\nSELECT\n  customerid,\n  transactionid,\n  date,\n  time,\n  gasstationid,\n  productid,\n  amount,\n  price\nFROM Calculated\nWHERE\n  (earliest_fail_id IS NOT NULL AND fail_id = earliest_fail_id)\n  OR\n  (earliest_fail_id IS NULL AND pass_id = last_pass_id);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 68, "sol_sql": ["WITH RECURSIVE linked_list(id, parent_id, depth) AS (SELECT id, parent_id, 0 FROM lineage WHERE id = 1001 OR id = 1201 UNION ALL SELECT g.id, g.parent_id, ll.depth + 1 FROM lineage g INNER JOIN linked_list ll ON ll.parent_id = g.id WHERE depth < 10000) SELECT string_agg(id::TEXT, ',') AS ids, parent_id FROM linked_list GROUP BY parent_id HAVING COUNT(DISTINCT id) > 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 69, "sol_sql": ["SELECT * FROM user_actions AS a WHERE a.action = 'SEARCH' AND NOT EXISTS (SELECT 1 FROM user_actions WHERE user_id = a.user_id AND action = 'BUY' AND action_time > a.action_time AND (action_time < (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) OR (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) IS NULL));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 70, "sol_sql": ["SELECT cte.id, c.name FROM (SELECT card_order FROM decks WHERE id = 1) d  CROSS JOIN UNNEST(d.card_order) WITH ORDINALITY cte(id, idx)  INNER JOIN cards c ON c.id = cte.id ORDER BY cte.idx;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 71, "sol_sql": ["SELECT ord.*, prd.price FROM order_cards ord LEFT JOIN LATERAL (SELECT prd.* FROM card_prices prd WHERE prd.card_id = ord.card_id and prd.start_date <= ord.order_date ORDER BY start_date DESC LIMIT 1) prd ON TRUE"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 72, "sol_sql": ["SELECT player_id, cols ->> 'goals' AS goals, cols ->> 'assists' AS assists, cols ->> 'yellow_cards' AS yellow_cards, cols ->> 'red_cards' AS red_cards FROM (SELECT player_id, (SELECT jsonb_object_agg(k, v) FROM unnest(string_to_array(stats_keys, ','), string_to_array(stats_values, ',')) AS x(k, v)) AS cols FROM player_stats) x ORDER BY player_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 73, "sol_sql": ["UPDATE teams_config t SET configurations = (SELECT jsonb_agg(a.elem) FROM jsonb_array_elements(t.configurations) AS a(elem) WHERE (a.elem ->> 'id' = '101') IS NOT TRUE) WHERE t.configurations @> '[{\"id\":101}]';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_sqls_result = execute_queries([\"SELECT * FROM teams_config;\"], db_name, conn)[0]\n    assert test_pred_sqls_result[0][0] == [{'id': 100, 'name': 'testOne', 'settings': 'settingOne'}], f'Expected the object with id = 101 is deleted and only the object with id = 100 is left in the configurations column. But got: {test_pred_sqls_result[0][0]}'\n"]}
{"instance_id": 74, "sol_sql": ["SELECT begin_date, end_date, (DATE_PART('year', end_date) - DATE_PART('year', begin_date)) * 12 + DATE_PART('month', end_date) - DATE_PART('month', begin_date) - CASE WHEN begin_date > date_trunc('month', begin_date) THEN 1 ELSE 0 END AS full_calendar_months FROM race_dates;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 75, "sol_sql": ["\n    INSERT INTO new_attendance (\n        link_to_event, \n        link_to_member, date\n    ) VALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW())\n    ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET\n        date = NOW();\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls,db_name,conn)\n    queries = [\"SELECT * FROM new_attendance WHERE link_to_event = 'reciRZdAqNIKuMC96' AND link_to_member = 'recL94zpn6Xh6kQii';\"]\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    ori_date = res[0][-1]\n    execute_queries(pred_sqls,db_name,conn)\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    new_date = res[0][-1]\n    assert ori_date != new_date\n    "]}
{"instance_id": 76, "sol_sql": ["\n        CREATE FUNCTION pg_try_advisory_lock_with_timeout(key bigint) RETURNS boolean\n        SET lock_timeout TO '1s'\n        AS $$\n        BEGIN\n        PERFORM pg_advisory_lock(key);\n        RETURN true;\n        EXCEPTION\n        WHEN lock_not_available OR deadlock_detected THEN\n            RETURN false;\n        END;\n        $$\n        LANGUAGE plpgsql;          \n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT pg_try_advisory_lock_with_timeout(12345);\"]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    print(res)\n    assert res[0][0] == True or res[0][0] == False\n    "]}
{"instance_id": 77, "sol_sql": ["\n        SELECT\n            link_to_member,\n            ROUND(SUM(hours)::NUMERIC, -1) AS rounded_hours,\n            RANK() OVER (ORDER BY ROUND(SUM(hours)::NUMERIC, -1) DESC) AS rank\n        FROM attendance\n        GROUP BY link_to_member\n        ORDER BY rank, link_to_member;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert int(pred_query_result[-1][1]) == 120\n    "]}
{"instance_id": 78, "sol_sql": ["\n        SELECT \n            CASE \n                WHEN EXISTS (\n                    SELECT 1 \n                    FROM pg_indexes \n                    WHERE tablename = 'account' \n                    AND indexname = 'ix_account'\n                ) THEN TRUE\n                ELSE FALSE\n            END AS index_exists;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == True\n    queries = [\"DROP INDEX ix_account;\"]\n    execute_queries(queries,db_name,conn)\n    res, _, _ = execute_queries(pred_sqls,db_name,conn)\n    assert res[0][0] == False\n    "]}
{"instance_id": 79, "sol_sql": ["\n        drop view findcount;\n        create or replace view findcount(season, team_count) as\n        select\n            season,\n            findteam(season) as team_count\n        from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n        \"\"\"\n        SELECT \n            CASE \n                WHEN pg_type.typname = 'float8' THEN TRUE \n                ELSE FALSE \n            END AS is_float\n        FROM pg_attribute\n        JOIN pg_class ON pg_attribute.attrelid = pg_class.oid\n        JOIN pg_type ON pg_attribute.atttypid = pg_type.oid\n        WHERE pg_class.relname = 'findcount' \n        AND pg_attribute.attname = 'team_count'\n        AND pg_attribute.attnum > 0;\n        \"\"\"\n    ]\n    \n    res, _, _ = execute_queries(queries,db_name,conn)\n    assert res[0][0] == True\n    "]}
{"instance_id": 80, "sol_sql": ["\n        select posttypeid,\n        sum(case when tags like '%bayesian%'\n                or tags like '%distributions%'\n            then 1 else 0 end) as keyword_count\n        from posts\n        group by posttypeid\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == 2\n    assert pred_query_result[0][1] == 1\n    assert pred_query_result[1][0] == 1\n    assert pred_query_result[1][1] == 2\n    "]}
{"instance_id": 81, "sol_sql": ["SELECT customerid, transaction, FIRST_VALUE(transaction) OVER (PARTITION BY customerid, transactionid ORDER BY transaction RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS first_transaction, amount, type, transactionid FROM transaction_info WHERE customerid = 1 ORDER BY customerid, transaction"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 82, "sol_sql": ["SELECT count(bond_id), molecule_id FROM bond GROUP BY molecule_id ORDER BY molecule_id, MAX(last_update) DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 83, "sol_sql": ["SELECT entity_id, coalesce(height, lag(height, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS height, coalesce(weight, lag(weight, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS weight, updated_at FROM (SELECT entity_id, MAX(CASE WHEN column_id = 'height' THEN value::int END) AS height, MAX(CASE WHEN column_id = 'weight' THEN value::int END) AS weight, updated_at FROM player_stats_changes GROUP BY entity_id, updated_at) AS changes;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = 0 if any('json_object_agg' in sql.lower() for sql in pred_sqls) else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"instance_id": 84, "sol_sql": ["WITH RECURSIVE qr1(item, subgroup) AS (SELECT id, subgroup1 FROM superhero_group WHERE subgroup1 IS NOT NULL), qr2(item, subgroup) AS (SELECT id, subgroup2 FROM superhero_group WHERE subgroup2 IS NOT NULL), qr(item, subgroup) AS (SELECT * FROM qr1 UNION ALL SELECT * FROM qr2), cte(item, other, items) AS (SELECT item, item, ARRAY[item] FROM qr UNION ALL SELECT cte.item, g.item, cte.items || g.item FROM cte JOIN qr ON qr.item = cte.other JOIN qr g ON g.subgroup = qr.subgroup WHERE g.item <> ALL (cte.items)) SELECT item, MIN(qr1.subgroup) AS sg1, MIN(qr2.subgroup) AS sg2, DENSE_RANK() OVER (ORDER BY MIN(other)) AS grp FROM cte LEFT JOIN qr1 USING (item) LEFT JOIN qr2 USING (item) GROUP BY item ORDER BY item;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 85, "sol_sql": ["select * from superhero where publisher_id = 1 union select * from superhero where id in (select superhero_id from hero_access f where '{1}' && read_acl) order by id limit 10;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 86, "sol_sql": ["WITH r AS (SELECT id, date_of_visit, sum(sessions) as sessions, sum(pageviews) as pageviews, sum(bounces) as bounce, coalesce(utm_campaign, '') as utm_campaign, coalesce(utm_source, '') as utm_source, coalesce(utm_medium, '') as utm_medium, coalesce(utm_content, '') as utm_content, coalesce(utm_term, '') as utm_term FROM report as r GROUP BY id, date_of_visit, cube(6, 7, 8, 9, 10)) SELECT r.* FROM r JOIN utm as u ON r.id = u.row_id AND (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT DISTINCT FROM (u.utm_campaign, u.utm_source, u.utm_medium, u.utm_content, u.utm_term) WHERE 'NA' IN (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT TRUE;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count = sum('union' in sql.lower() for sql in pred_sqls)\n    result = 0 if count > 3 else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"instance_id": 87, "sol_sql": ["SELECT\n    c.id,\n    c.text,\n    (\n        SELECT array_agg(matches[1])\n        FROM regexp_matches(\n            c.text,\n            '(\\{[^{}]*\\})',\n            'g'\n        ) AS matches\n    ) AS bracketed_tokens\nFROM cards AS c;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": 88, "sol_sql": ["WITH ranked_races AS (SELECT gender_id, race_id, COUNT(*) AS count, DENSE_RANK() OVER (PARTITION BY gender_id ORDER BY COUNT(*) DESC) AS rank FROM superhero GROUP BY gender_id, race_id) SELECT gender_id, race_id, count FROM ranked_races WHERE rank <= 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 89, "sol_sql": ["SELECT r.* FROM unnest(ARRAY['6d268c95-c176-5766-9a46-c14f739aba1c', '56f4935b-f6c5-59b9-88bf-9bcce20247ce', '8dfc67e9-8323-5d1f-9e25-9f9394abd5a0', '5ac794d2-4c66-5332-afb1-54b24bc11823', '60f49caf-3583-5f85-b4b3-08dca73a8628']::uuid[]) AS p(uuid) CROSS JOIN LATERAL (SELECT id, date, text, uuid FROM rulings r WHERE r.uuid = p.uuid::varchar ORDER BY date DESC LIMIT 3) r ORDER BY uuid, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 90, "sol_sql": ["WITH riders AS ( SELECT DISTINCT id, name, total_points FROM racers), places AS (SELECT id, name, RANK() OVER (ORDER BY total_points DESC) AS place FROM riders) SELECT p.place, r.*  FROM places p JOIN racers r ON (r.id, r.name) = (p.id, p.name);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 91, "sol_sql": ["SELECT s.cds, s.cds IN (SELECT cdscode FROM frpm) AS frpm_exists FROM satscores s order by cds"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 92, "sol_sql": ["WITH first_purchase AS (SELECT customer_id, MIN(month_year) AS first_month FROM orders GROUP BY customer_id) SELECT o.month_year, COUNT(DISTINCT o.customer_id) AS repeat_customers FROM orders o JOIN first_purchase fp ON o.customer_id = fp.customer_id WHERE o.month_year > fp.first_month GROUP BY o.month_year ORDER BY o.month_year;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 93, "sol_sql": ["SELECT player_name, event_date AS joined_date, (SELECT MIN(event_date) FROM player_movements pm1 WHERE pm1.player_name = pm.player_name AND pm1.event = 'Leave' AND pm1.event_date > pm.event_date) AS left_date FROM player_movements pm WHERE event = 'Join'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 94, "sol_sql": ["SELECT id, ((gk_diving + gk_handling + gk_kicking + gk_positioning + gk_reflexes) - GREATEST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes) - LEAST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes)) / 3.0 AS adjusted_average FROM player_attributes ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 95, "sol_sql": ["CREATE INDEX idx_a ON trans (account_id, date DESC, trans_id);", "SELECT DISTINCT ON (t.account_id) t.trans_id, t.account_id, t.date, t.type, t.amount, t.balance FROM trans t;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 96, "sol_sql": ["\n        select account_id, date, \n        sum(amount) OVER w as total_amount, \n        sum(balance) OVER w as total_balance, \n        count(trans_id) OVER w as total_transactions\n        from trans WINDOW w AS (PARTITION BY account_id, date);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    \n    lower_sqls = ' '.join(pred_sqls)\n    lower_sqls = lower_sqls.lower()\n    keyword_count = lower_sqls.count('partition by')\n    assert keyword_count == 1, f\"You need to just use one PARTITION definition.\"\n    "]}
{"instance_id": 97, "sol_sql": ["\n        SELECT * FROM transactions_1k WHERE Date < '2012-08-24' OR (Date = '2012-08-24' AND Time > '10:00:00') OR (Date = '2012-08-24' AND Time = '10:00:00' AND Amount < 20);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": 98, "sol_sql": ["\n        SELECT client.gender, loan.amount, loan.duration, account.date FROM loan JOIN account ON loan.account_id = account.account_id JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE loan.date BETWEEN '1996-01-01' AND '1996-12-31';\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": 99, "sol_sql": ["select session_id, post_id, max(case when event_name='view_start' then ts end) start_time, max(case when event_name='view_end' then ts end) end_time, case when max(case when event_name='view_end' then ts end) - max(case when event_name='view_start' then ts end) > 3 and max(view_perc) > 0.8 then 'yes' else 'no' end as has_impact from (select *, row_number() over (partition by session_id, post_id order by ts) rn from view_logs) t group by session_id, post_id, (rn-1)/ 2 order by session_id, post_id, min(ts);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 100, "sol_sql": ["WITH deleted_rows AS (DELETE FROM superhero WHERE id = 999 RETURNING 1) SELECT COALESCE((SELECT * FROM deleted_rows), 0)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 1, f'Expected 1 row, but found {len(pred_sqls_result)} rows'"]}
{"instance_id": 101, "sol_sql": ["CREATE OR REPLACE FUNCTION GapFillInternal(s anyelement, v anyelement) RETURNS anyelement LANGUAGE plpgsql AS $$ BEGIN IF s IS NULL AND v IS NULL THEN RETURN NULL; ELSIF v IS NULL THEN RETURN s; ELSE RETURN v; END IF; END; $$;", "CREATE AGGREGATE GapFill(anyelement) (SFUNC=GapFillInternal, STYPE=anyelement);", "SELECT id, str, val, GapFill(val) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS valx FROM example;;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 102, "sol_sql": ["UPDATE table_A SET is_active = false WHERE parent_id IS NULL AND is_active = true AND id = ANY (SELECT a2.parent_id FROM table_A a2 JOIN table_B b ON a2.foreign_id = b.id WHERE b.deleted = true) RETURNING *"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 103, "sol_sql": ["SELECT SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) AS yesterday_revenue, ROUND((SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) - SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END), 0), 2) AS pct_change_week_ago, SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) AS mtd, ROUND((SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) - SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END), 0), 2) AS pct_change_month_prior FROM transactions;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # results = execute_queries(['SELECT * FROM transactions;'], db_name, conn)[0]\n    # assert 1== 0, f'{results}'\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 104, "sol_sql": ["SELECT name, convertedManaCost, ROUND(avg(convertedManaCost::numeric) OVER(ORDER BY id ROWS BETWEEN 8 PRECEDING AND CURRENT ROW), 2) AS nine_card_avg FROM cards WHERE name LIKE 'A%' ORDER BY id DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 105, "sol_sql": ["WITH approved_counts AS (SELECT hero_id, attribute_id, COUNT(CASE WHEN (value->>'approved')::boolean THEN 1 END) AS approved_cnt FROM hero_attribute a CROSS JOIN LATERAL jsonb_array_elements(a.ss) AS value GROUP BY hero_id, attribute_id) SELECT a.hero_id, a.attribute_id, jsonb_array_length(a.ss) AS ss_cnt, ac.approved_cnt FROM hero_attribute a JOIN approved_counts ac ON a.hero_id = ac.hero_id AND a.attribute_id = ac.attribute_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 106, "sol_sql": ["SELECT * FROM trans WHERE EXTRACT(MONTH FROM date) = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(DAY FROM date) = EXTRACT(DAY FROM CURRENT_DATE) ORDER BY date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 107, "sol_sql": ["\nselect\n  data.id,\n  jsonb_object_agg(data.key, case when data.key = 'dis' then data.value else data.value->0 end) as final_json\nfrom (\n    select\n      mt.id,\n      props.key,\n      jsonb_agg(distinct coalesce(j.dis, props.value)) as value\n    from test as mt\n    cross join jsonb_each(mt.data) as props\n    left join jsonb_array_elements(case when props.key = 'dis' then props.value end) as j(dis) on 1=1\n    group by\n      mt.id,\n      props.key\n) data\ngroup by\n  data.id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    assert isinstance(concatenated_json, dict), f'Expected result to be a dictionary, but found {type(concatenated_json)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    expected_values = {\n        \"dir\": 1,\n        \"dis\": [\"bye\", \"close\", \"hello\"],\n        \"purpose\": {\"text\": \"hi\", \"score\": 0.1}\n    }\n\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'\n    "]}
{"instance_id": 108, "sol_sql": ["\n    DO $$ \n    DECLARE \n        i integer; \n        j integer; \n        k text; \n    BEGIN \n        FOR i, j, k IN \n            SELECT unnest(ARRAY[11, 20]::integer[]), \n                   unnest(ARRAY[505942, 155782]::integer[]), \n                   unnest(ARRAY['2016-02-18 00:00:00', '2015-10-16 00:00:00']::text[])\n        LOOP \n            UPDATE Player_Attributes \n            SET overall_rating = i \n            WHERE player_api_id = j \n            AND date = k; \n        END LOOP; \n    END $$;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 505942 AND date = '2016-02-18 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    test_pred_query_result_2 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 155782 AND date = '2015-10-16 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    assert len(test_pred_query_result_1) == 1, 'There should be exactly one record for player_api_id = 505942 and date = 2016-02-18.'\n    assert test_pred_query_result_1[0][4] == 11, 'Player 505942 overall_rating should be updated to 11.'\n    \n    assert len(test_pred_query_result_2) == 1, 'There should be exactly one record for player_api_id = 155782 and date = 2015-10-16.'\n    assert test_pred_query_result_2[0][4] == 20, 'Player 155782 overall_rating should be updated to 20.'\n"]}
{"instance_id": 109, "sol_sql": ["\nSELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected at least one result with fastestLapTime = 1:35.405, but found none.'\n    assert all(row[0] is not None for row in test_pred_query_result_1), 'Expected all resultIds to be valid, but found NULL values.'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_2) == 1, f'Expected exactly 1 result with fastestLapTime = 1:35.405, but found {len(test_pred_query_result_2)} results.'\n    assert test_pred_query_result_2[0][0] == 23, f'Expected resultId to be 23, but found {test_pred_query_result_2[0][0]}.'\n"]}
{"instance_id": 110, "sol_sql": ["\nSELECT raceId,\n       jsonb_object_agg(COALESCE(position::text, 'Unknown') , COALESCE(cnt::text, '0')) AS json_count\nFROM (\n    SELECT raceId,\n           position,\n           COUNT(*) AS cnt\n    FROM results\n    GROUP BY raceId, position\n) AS aggregated_counts\nGROUP BY raceId\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 1;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_1[0][0] == 1, f'Expected count of position 1 in race 19 to be 1, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 2;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_2[0][0] == 1, f'Expected count of position 2 in race 19 to be 1, but found {test_pred_query_result_2[0][0]}'\n    test_pred_query_result_3 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 3;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_3[0][0] == 1, f'Expected count of position 3 in race 19 to be 1, but found {test_pred_query_result_3[0][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) > 0, 'Expected at least one row in the result, but found none.'\n    assert isinstance(pred_query_result[0][1], dict), 'Expected json_count to be a dictionary, but found something else.'\n    assert '1' in pred_query_result[0][1], 'Expected position 1 to be included in the json_count for raceId 1.'\n"]}
{"instance_id": 111, "sol_sql": ["\nSELECT * FROM Match WHERE (match_api_id, date, id) < (492473, '2008-08-17 00:00:00', 1) ORDER BY match_api_id DESC, date DESC, id DESC LIMIT 3;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) == 3, f'Expected 3 rows, but found {len(test_pred_query_result_1)} rows'\n    assert test_pred_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_pred_query_result_1[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) == 3, f'Expected 3 rows, but found {len(test_sol_query_result_1)} rows'\n    assert test_sol_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_sol_query_result_1[0][0]}'\n    "]}
{"instance_id": 112, "sol_sql": ["\nSELECT s.School FROM schools s WHERE s.County IN ('Alameda', 'Contra Costa') \nGROUP BY s.School HAVING COUNT(DISTINCT s.County) = 2;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_pred_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_pred_query_result_1[1][0]}'\n    assert test_pred_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_pred_query_result_1[2][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_sol_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_sol_query_result_1[1][0]}'\n    assert test_sol_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_sol_query_result_1[2][0]}'\n    "]}
{"instance_id": 113, "sol_sql": ["SELECT DISTINCT ON (name) raceid, name, date FROM races ORDER BY name, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 114, "sol_sql": ["SELECT t.team_name, o.outcome FROM (VALUES('Team A'),('Team B')) AS t(team_name) CROSS JOIN (VALUES('win'),('lose'),('draw')) AS o(outcome);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'european_football_2', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'european_football_2', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 115, "sol_sql": ["\nWITH RankedFRPM AS (\n    SELECT *, \n           ROW_NUMBER() OVER (\n               PARTITION BY \"County Code\" \n               ORDER BY \"Enrollment (K-12)\" DESC NULLS LAST\n           ) AS rn \n    FROM frpm\n    WHERE \"County Code\" IS NOT NULL AND \"Enrollment (K-12)\" IS NOT NULL\n) \nSELECT * \nFROM RankedFRPM \nWHERE rn = 2;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 116, "sol_sql": ["WITH RECURSIVE expanded AS (\n    SELECT \n        name, \n        price_per_unit, \n        ROW_NUMBER() OVER (ORDER BY price_per_unit, name) AS row_number\n    FROM race_materials\n    CROSS JOIN generate_series(1, quantity)\n), \npurchased (name, remaining, next_row_number) AS (\n    SELECT \n        NULL::TEXT AS name, \n        100 AS remaining, \n        1::BIGINT AS next_row_number\n    UNION ALL\n    SELECT \n        expanded.name, \n        purchased.remaining - expanded.price_per_unit, \n        expanded.row_number + 1\n    FROM purchased\n    JOIN expanded \n        ON expanded.row_number = purchased.next_row_number\n    WHERE expanded.price_per_unit <= purchased.remaining\n)\nSELECT COUNT(name) AS qty\nFROM purchased;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert int(pred_query_result[0][0]) == 32, f\"Value returned {int(pred_query_result[0][0])} but expected 32\"\n"]}
{"instance_id": 117, "sol_sql": ["SELECT d.forename, d.surname, r.race_results\nFROM (\n   SELECT driverid, \n          jsonb_agg(jsonb_build_object('laps', r.laps, 'position', r.position)) AS race_results\n   FROM results r\n   WHERE EXISTS (\n      SELECT 1 \n      FROM results r1\n      WHERE r1.driverid = r.driverid\n      AND   r1.laps = 56\n      AND   r1.position = 1\n   )\n   GROUP BY driverid\n) r\nJOIN drivers d ON d.driverid = r.driverid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(sol_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 118, "sol_sql": ["INSERT INTO historical_rating (player_fifa_api_id, player_api_id, grouped_rating) SELECT player_fifa_api_id, player_api_id, STRING_AGG(overall_rating::TEXT, ',') AS grouped_rating FROM player_attributes GROUP BY player_fifa_api_id, player_api_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT player_api_id FROM historical_rating WHERE player_fifa_api_id = 227760;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 582500, f'Expected player_api_id to match, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT grouped_rating FROM historical_rating WHERE player_api_id = 306507;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == '64,64,64,64,64,63,63,63,63,64,64,64,62,62', f'Expected grouped_rating to match, but found {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": 119, "sol_sql": ["SELECT DISTINCT id, acceptedanswerid, posttypeid, score\nFROM (\n  SELECT p.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE p.score >= 20\n  UNION ALL\n  SELECT c.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE NOT p.score >= 20 AND c.score >= 20\n) x;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 120, "sol_sql": ["SELECT DISTINCT s.id \nFROM superhero s \nWHERE s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Flight'\n    )\n) \nAND s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Telepathy'\n    )\n) \nAND s.id NOT IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id NOT IN (\n        (SELECT id FROM superpower WHERE power_name = 'Flight'), \n        (SELECT id FROM superpower WHERE power_name = 'Telepathy')\n    )\n);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 121, "sol_sql": ["WITH card_activity AS (\n  SELECT \n    to_date(fe.start_date_key::text, 'YYYYMMDD') AS start_date,\n    to_date(fe.end_date_key::text, 'YYYYMMDD') AS end_date,\n    dp.set_name,\n    dp.set_code,\n    fe.set_key\n  FROM fact_collection fe\n  INNER JOIN dim_set dp ON fe.set_key = dp.set_key\n)\nSELECT \n  date_trunc('month', month_series) AS month,\n  COUNT(DISTINCT fe.card_key) AS existing_cards,\n  sa.set_name\nFROM (\n  SELECT \n    generate_series(\n      (SELECT MIN(to_date(start_date_key::text, 'YYYYMMDD')) FROM fact_collection), \n      '2100-12-31', \n      INTERVAL '1 month'\n    ) AS month_series\n) AS months\nLEFT JOIN card_activity sa ON \n  sa.start_date <= month_series AND \n  (sa.end_date IS NULL OR sa.end_date >= month_series)\nLEFT JOIN fact_collection fe ON \n  fe.set_key = sa.set_key \n  AND fe.start_date_key <= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 31\n  AND (fe.end_date_key IS NULL OR fe.end_date_key >= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 1)\nGROUP BY month, sa.set_name\nLIMIT 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 122, "sol_sql": ["WITH data AS (  SELECT hero_id, mission_start, mission_end FROM superhero_missions ORDER BY hero_id, mission_start ), mark_gaps AS ( SELECT hero_id, mission_start, mission_end,  COALESCE(LAG(mission_end) OVER w < mission_start, true) AS is_end_grp FROM data WINDOW w AS (PARTITION BY hero_id ORDER BY mission_start) ), numbered_groups AS ( SELECT hero_id, SUM(is_end_grp::int) OVER (PARTITION BY hero_id  ORDER BY mission_start) AS grp_num, mission_start, mission_end FROM mark_gaps ) SELECT hero_id, MIN(mission_start) AS v_start, MAX(mission_end) AS v_stop FROM numbered_groups GROUP BY hero_id, grp_num  ORDER BY hero_id, v_start; "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 123, "sol_sql": ["SELECT to_timestamp(percentile_cont(0.5) within group (ORDER by cast (extract(epoch from releasedate) as integer)))::date FROM sets"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 124, "sol_sql": ["CREATE TABLE race_incidents ( incident_type VARCHAR(30) NOT NULL, incident_description VARCHAR(30) NOT NULL CHECK(CASE incident_type WHEN 'Engine failure' THEN incident_description IN ('Piston failure', 'Cylinder head gasket') WHEN 'Collision' THEN incident_description IN ('High-speed impact', 'Low-speed impact') END));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Piston failure');\"], db_name, conn)[0];\n    assert test_pred_query_result_1 == None, f'Expected 0 rows, but found {test_pred_query_result_1}'\n    test_pred_query_result_2 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'High-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_2 == None, f'Expected 0 rows, but found {test_pred_query_result_2}'\n    test_pred_query_result_3 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Cylinder head gasket');\"], db_name, conn)[0];\n    assert test_pred_query_result_3 == None, f'Expected 0 rows, but found {test_pred_query_result_3} rows'\n    test_pred_query_result_4 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Low-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_4 == None, f'Expected 0 rows, but found {test_pred_query_result_4}'\n    test_pred_query_result_5 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Piston failure');\"], db_name, conn)[1];\n    assert test_pred_query_result_5 == True, f'There should be constraint viloation error.'\n"]}
{"instance_id": 125, "sol_sql": ["UPDATE latest_trans a SET (amount, trans_id) = (SELECT amount, trans_id FROM trans t WHERE t.account_id = a.account_id ORDER BY t.trans_id DESC LIMIT 1);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"select max(trans_id) from trans where account_id = 1;\"], db_name, conn)[0]\n    test_pred_query_result_2 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 1;\"], db_name, conn)[0]\n    assert test_pred_query_result_2 == test_pred_query_result_1, f\"Expected equal but got {test_pred_query_result_1} {test_pred_query_result_2}\"\n\n    test_pred_query_result_3 = execute_queries([\"select max(trans_id) from trans where account_id = 107;\"], db_name, conn)[0]\n    test_pred_query_result_4 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 107;\"], db_name, conn)[0]\n    assert test_pred_query_result_3 == test_pred_query_result_4, f\"Expected equal but got {test_pred_query_result_3} {test_pred_query_result_4}\"\n\n    test_pred_query_result_5 = execute_queries(['SELECT COUNT(*) FROM latest_trans;'], db_name,conn)[0]\n    assert test_pred_query_result_5[0][0] == 4500, 'The total number of records in the attendance table should remain unchanged after the update.'\n"]}
{"instance_id": 126, "sol_sql": ["WITH RECURSIVE recuree AS (SELECT id AS league_id, name FROM League UNION ALL SELECT L.id AS league_id, L.name FROM League L JOIN recuree R ON L.id = R.league_id) SELECT * FROM recuree LIMIT 50;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 127, "sol_sql": ["CREATE OR REPLACE FUNCTION get_superhero_ids()\n  RETURNS SETOF jsonb\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    cols   text;    -- Will hold the comma-separated list of matching columns\n    sqlstr text;    -- Will hold the final SQL statement\nBEGIN\n    SELECT string_agg(quote_ident(column_name), ', ')\n      INTO cols\n      FROM information_schema.columns\n     WHERE table_name = 'superhero'\n       AND column_name LIKE '%_id';\n\n    IF cols IS NULL THEN\n        -- No columns matched; return nothing\n        RETURN;\n    END IF;\n\n    sqlstr := format(\n        'SELECT to_jsonb(row) \n         FROM (SELECT %s \n               FROM %I) AS row',\n        cols,\n        'superhero'\n    );\n    RETURN QUERY EXECUTE sqlstr;\nEND;\n$$;", "SELECT get_superhero_ids();"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": 128, "sol_sql": ["CREATE TYPE availability_enum AS ENUM (\n  'mtgo,paper',\n  'paper-only',\n  'mtgo-only'\n);", "CREATE OR REPLACE FUNCTION force_availability_default()\n  RETURNS TRIGGER\n  LANGUAGE plpgsql\nAS $$\nBEGIN\n  -- If the inserted row has availability = NULL, override it with the default\n  NEW.availability := 'mtgo,paper';\n  RETURN NEW;\nEND;\n$$;", "CREATE TRIGGER cards_before_insert\nBEFORE INSERT ON cards\nFOR EACH ROW\nWHEN (NEW.availability IS NULL)  -- only fires if availability is actually NULL\nEXECUTE FUNCTION force_availability_default();", "INSERT INTO cards (availability, borderColor)\nVALUES (NULL, 'black');"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    test_result = execute_queries([\"SELECT availability, borderColor FROM cards ORDER BY id DESC LIMIT 1;\"],db_name,conn)\n    assert test_result is not None and test_result[0] == [('mtgo,paper', 'black')]\n    return 1"]}
{"instance_id": 129, "sol_sql": ["CREATE OR REPLACE FUNCTION f_next_free_date(\n    _input_date date\n)\nRETURNS date\nLANGUAGE plpgsql STABLE STRICT\nAS $func$\nDECLARE\n    _candidate date := _input_date;\nBEGIN\n    LOOP\n        IF NOT EXISTS (\n            SELECT 1\n              FROM races\n             WHERE date = _candidate\n        )\n        THEN\n            RETURN _candidate;\n        END IF;\n        \n        _candidate := _candidate + INTERVAL '1 day';\n    END LOOP;\nEND;\n$func$;", "INSERT INTO seasons (year, url)\nVALUES (2023, 'http://example.com');", "SELECT f_next_free_date('2023-04-01');\n\nINSERT INTO races (raceid, year, round, circuitid, name, date, time, url)\nVALUES (\n    999,\n    2023,\n    1,\n    1,\n    'Test Grand Prix',\n    f_next_free_date('2023-04-01'),\n    '12:00:00',\n    'http://example.com'\n)RETURNING raceid, year, round, circuitid, name, date, time, url;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)\n    \n    test_result = execute_queries([\n        \"SELECT COUNT(*) FROM races WHERE date = '2023-04-01'\"\n    ], db_name, conn)\n    assert test_result and test_result[0][0][0] == 1, f\"Expect 1 row, but get {test_result[0][0][0]} rows\"\n    \n    return 1"]}
{"instance_id": 130, "sol_sql": ["SELECT r.name, r.date, ARRAY_AGG(lt.milliseconds ORDER BY lt.lap) AS lap_times FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId WHERE lt.driverId = 1 GROUP BY r.name, r.date ORDER BY r.date"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": 131, "sol_sql": ["WITH LatestLabs AS (SELECT ID, \"Examination Date\", Thrombosis, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY \"Examination Date\" DESC) AS rn FROM Examination) SELECT ID, MAX(CASE WHEN rn = 1 THEN Thrombosis END) AS Thrombosis_1, MAX(CASE WHEN rn = 2 THEN Thrombosis END) AS Thrombosis_2 FROM LatestLabs WHERE rn <= 2 GROUP BY ID"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 132, "sol_sql": ["with connections as ( select atom_id as atom from connected union all select atom_id2 as atom from connected ) select atom as id, count(*) as num from connections group by atom having count(*) = (select max(cnt) from (select count(*) as cnt from connections group by atom) as max_connections);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 133, "sol_sql": ["CREATE OR REPLACE FUNCTION trigger_function()\nRETURNS TRIGGER\nAS $BODY$\nBEGIN\n    INSERT INTO public.destination_table (\n        created_at,\n        match_id,\n        player_id,\n        event_type,\n        url,\n        user_id\n    )\n    VALUES (\n        NEW.created_at,\n        NEW.match_id,\n        NEW.player_id,\n        NEW.event_type,\n        split_part(NEW.url::text, '?', 1),\n        ((NEW.data -> 'local_storage') -> 'data') ->> 'user_id'\n    );\n\n    RETURN NEW;\nEND;\n$BODY$\nLANGUAGE plpgsql;", "CREATE TRIGGER after_insert_source\nAFTER INSERT ON public.source_table\nFOR EACH ROW\nEXECUTE PROCEDURE trigger_function();", "INSERT INTO public.source_table (\n    created_at,\n    match_id,\n    player_id,\n    event_type,\n    url,\n    data\n)\nVALUES (\n    NOW(),                     -- created_at\n    101,                       -- match_id\n    202,                       -- player_id\n    'goal',                    -- event_type\n    'http://example.com?foo=bar', -- url\n    '{\n        \"local_storage\": {\n            \"data\": {\n                \"user_id\": \"u12345\"\n            }\n        }\n    }'::jsonb                  -- data\n);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)\n    test_result = execute_queries([\"SELECT * FROM public.destination_table;\"], db_name, conn)\n    assert test_result and test_result[0][0][-1] == 'u12345'\n    assert test_result and test_result[0][0][-2] == 'http://example.com'\n    assert test_result and test_result[0][0][-3] == 'goal'\n    return 1"]}
{"instance_id": 134, "sol_sql": ["WITH main AS (\n    SELECT DISTINCT ON (main_request_uuid)\n           id,\n           superhero_id,\n           superpower_id,\n           status,\n           created_at\n    FROM public.superhero_requests\n    ORDER BY main_request_uuid, retry_number DESC, id DESC\n)\nSELECT\n    m.superhero_id AS \"superheroId\",\n    p.power_name   AS \"power\",\n    COUNT(*) AS \"totalRequests\",\n    SUM(CASE WHEN m.status = 'success' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS \"successRate\"\nFROM main m\nJOIN public.superpower p\n    ON m.superpower_id = p.id\nWHERE m.created_at >= CURRENT_DATE - INTERVAL '30 days'\n  AND m.created_at <= CURRENT_DATE\nGROUP BY\n    m.superhero_id,\n    p.power_name\nLIMIT 10;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 135, "sol_sql": ["SELECT raceId, name, year, COUNT(*) OVER (PARTITION BY year) as same_year_races FROM races;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 136, "sol_sql": ["CREATE INDEX price_uuid_time_desc ON card_prices (uuid asc, timestamp desc) INCLUDE (price) WHERE price > 0;", "SELECT LEAST ((SELECT min(price) FROM card_prices WHERE timestamp >= '2022-07-12T15:30:00-00:00' AND uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' AND price > 0), (SELECT price FROM card_prices WHERE timestamp < '2022-07-12T15:30:00-00:00' AND uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' AND price > 0 ORDER BY timestamp DESC LIMIT 1));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 137, "sol_sql": ["with hero_attribute_data (hero_id, attribute_id, max_score, year_1, year_2, year_3, year_4, year_5) as (values (1, 1, 80, 80, 80, 80, null, 80), (2, 2, 90, 90, 85, 90, 88, 90), (3, 3, 75, 75, 70, null, 75, 75), (4, 4, 60, null, 60, 60, 60, null)), score_check as (select *, case when (coalesce(year_1::character, 'x') || coalesce(year_2::character, 'x') || coalesce(year_3::character, 'x') || coalesce(year_4::character, 'x') || coalesce(year_5::character, 'x') ~ '\\d+x\\d+' or year_1 <> max_score or year_2 <> max_score or year_3 <> max_score or year_4 <> max_score or year_5 <> max_score) then false else true end is_a_match from hero_attribute_data) select * from score_check where is_a_match is false;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 138, "sol_sql": ["WITH RECURSIVE cte AS (SELECT item_id, item_price, quantity, resource_id, resource_price FROM store UNION ALL SELECT s.item_id, s.item_price, c.quantity, c.resource_id, c.resource_price FROM store s INNER JOIN cte c ON c.item_id = s.uses_item_id), full_craft_prices AS (SELECT item_id, sum(coalesce(resource_price * quantity, 0)) AS full_craft_price FROM cte GROUP BY item_id) SELECT s.item_id, s.item_price AS retail_price, sum(coalesce(uses_item_price, 0) * quantity) + sum(coalesce(resource_price * quantity, 0)) AS partial_craft_price, f.full_craft_price FROM store s LEFT JOIN full_craft_prices f ON s.item_id = f.item_id GROUP BY s.item_id, s.item_price, f.full_craft_price;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 139, "sol_sql": ["UPDATE superhero s SET full_name = 'Superman' FROM team_member_superhero tms JOIN team_member tm ON tms.team_member_id = tm.id WHERE s.id = tms.superhero_id AND tm.team_id = 91;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sql_result = execute_queries([\"SELECT full_name FROM superhero WHERE id = 1;\"], db_name, conn)[0]\n    assert test_sql_result[0][0] == \"Superman\", f'Expected the full name is updated to Superman, but found {test_sql_result[0][0]}'"]}
{"instance_id": 140, "sol_sql": ["WITH norm_matches AS ( SELECT id AS match_id, home_team_api_id AS team_id, home_team_goal AS goals, CASE WHEN home_team_goal > away_team_goal THEN 'W' WHEN home_team_goal = away_team_goal THEN 'D' WHEN home_team_goal < away_team_goal THEN 'L' END AS outcome FROM match UNION ALL SELECT id AS match_id, away_team_api_id AS team_id, away_team_goal AS goals, CASE WHEN home_team_goal > away_team_goal THEN 'L' WHEN home_team_goal = away_team_goal THEN 'D' WHEN home_team_goal < away_team_goal THEN 'W' END AS outcome FROM match ), points (outcome, value) AS ( VALUES ('W', 3), ('D', 1), ('L', 0) ) SELECT t.team_long_name, count(1) AS matches, count(1) filter (WHERE m.outcome = 'W') AS victories, count(1) filter (WHERE m.outcome = 'L') AS defeats, count(1) filter (WHERE m.outcome = 'D') AS draws, sum(p.value) AS score FROM team t JOIN norm_matches m ON m.team_id = t.team_api_id JOIN points p ON p.outcome = m.outcome GROUP BY t.team_long_name ORDER BY t.team_long_name"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 141, "sol_sql": ["SELECT id, COALESCE(MAX(CASE WHEN diagnosis = 'SLE' THEN 'TRUE' END), 'FALSE') AS SLE, COALESCE(MAX(CASE WHEN diagnosis = 'PSS' THEN 'TRUE' END), 'FALSE') AS PSS, COALESCE(MAX(CASE WHEN diagnosis = 'RA susp.' THEN 'TRUE' END), 'FALSE') AS RA_susp FROM examination GROUP BY id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    global pred_query_result\n    assert len(pred_query_result) == 70, f'Expected 70 rows, but found {len(pred_query_result)} rows.'\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 142, "sol_sql": ["SELECT COALESCE(hbi.id, hbialt.id) as id, COALESCE(hbi.hero_name, hbialt.hero_name) as name, COALESCE(hbialt.date_of_birth, hbi.birthdate) AS birthdate FROM hero_birth_info hbi FULL OUTER JOIN hero_birth_info_alt hbialt ON hbi.id = hbialt.id order by COALESCE(hbi.id, hbialt.id)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 143, "sol_sql": ["CREATE OR REPLACE FUNCTION reindex_superhero_ids(IN BIGINT) RETURNS VOID LANGUAGE plpgsql AS $proc$ BEGIN IF EXISTS ( SELECT FROM pg_catalog.pg_class WHERE  relname = 'id_seq_temp' AND relnamespace = pg_my_temp_schema() AND relkind = 'S') THEN ALTER SEQUENCE id_seq_temp RESTART; ELSE CREATE TEMP SEQUENCE id_seq_temp; END IF; UPDATE superhero SET hair_colour_id = hair_colour_id + 2000 WHERE publisher_id = $1; UPDATE superhero SET hair_colour_id = nextval('id_seq_temp') WHERE publisher_id = $1; END $proc$;;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"SELECT reindex_superhero_ids(9)\"], db_name, conn)\n    test_sql_result = execute_queries([\"SELECT hair_colour_id FROM superhero WHERE publisher_id = 9;\"], db_name, conn)[0]\n    assert test_sql_result == [(1,), (2,), (3,), (4,)], f'Expected hair_color_id to be 1, 2, 3, 4, but found {test_sql_result}.'\n"]}
{"instance_id": 144, "sol_sql": ["ALTER TABLE card_versions  DROP CONSTRAINT pk_card_versions, ADD  CONSTRAINT pk_card_versions PRIMARY KEY (defn_id, attr_id, seqnr) DEFERRABLE", "UPDATE card_versions SET seqnr = seqnr + 1 WHERE defn_id = 100 AND attr_id = 100 AND seqnr >= 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sql_result = execute_queries([\"SELECT seqnr FROM card_versions;\"], db_name, conn)[0]\n    assert test_sql_result == [(2,), (3,), (4,), (5,), (6,)], f'Expected the seqrs are updated to 2, 3, 4, 5, 6, but found {test_sql_result}'"]}
{"instance_id": 145, "sol_sql": ["WITH table_jsonb AS (SELECT id, jsonb_insert('{}','{buildupplayspeed}',to_jsonb(buildupplayspeed)) as attributes FROM team_attributes WHERE team_api_id = 1773) UPDATE team_attributes SET attributes_jsonb = table_jsonb.attributes FROM table_jsonb WHERE team_attributes.id = table_jsonb.id AND team_attributes.team_api_id = 1773 RETURNING team_attributes.id, team_attributes.attributes_jsonb;", "SELECT id, attributes_jsonb FROM team_attributes WHERE team_api_id = 1773 ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 146, "sol_sql": ["WITH RECURSIVE atom_ancestors AS ( SELECT atom_id, parent_id, enabled FROM connection WHERE atom_id = 4 UNION ALL SELECT c.atom_id, c.parent_id, c.enabled FROM connection c INNER JOIN atom_ancestors aa ON c.atom_id = aa.parent_id) SELECT * FROM atom_ancestors WHERE NOT EXISTS (SELECT 1 FROM atom_ancestors WHERE enabled = false)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 147, "sol_sql": ["\nselect\n  preference_data.customerid,\n  jsonb_object_agg(preference_data.key, case when preference_data.key = 'dis' then preference_data.value else preference_data.value->0 end) as final_json\nfrom (\n    select\n      mt.customerid,\n      props.key,\n      jsonb_agg(distinct coalesce(j.dis, props.value)) as value\n    from card_preference as mt\n    cross join jsonb_each(mt.preference) as props\n    left join jsonb_array_elements(case when props.key = 'dis' then props.value end) as j(dis) on 1=1\n    group by\n      mt.customerid,\n      props.key\n) preference_data\ngroup by\n  preference_data.customerid;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    assert isinstance(concatenated_json, dict), f'Expected result to be a dictionary, but found {type(concatenated_json)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    expected_values = {\n        \"dir\": 1,\n        \"dis\": [\"bye\", \"close\", \"hello\"],\n        \"purpose\": {\"text\": \"hi\", \"score\": 0.1}\n    }\n\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'"]}
{"instance_id": 148, "sol_sql": ["\nSELECT hero_id, attribute_value AS Difference FROM hero_attribute \nJOIN attribute ON hero_attribute.attribute_id = attribute.id GROUP BY hero_id, attribute_value \nHAVING COUNT(DISTINCT attribute_value) > 1 UNION ALL SELECT hero_id, attribute_value AS Difference \nFROM hero_attribute JOIN attribute ON hero_attribute.attribute_id = attribute.id \nGROUP BY hero_id, attribute_value HAVING COUNT(DISTINCT attribute_id) > 1 \nOR (COUNT(attribute_id) != COUNT(*) AND COUNT(DISTINCT attribute_id) > 0)\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'error_sql query did not return any records with attribute differences.'\n    assert test_pred_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_pred_query_result_1[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, 'sol_sql query did not return any records with attribute differences.'\n    assert test_sol_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_sol_query_result_1[0][1]}'\n"]}
{"instance_id": 149, "sol_sql": ["INSERT INTO member(member_id, first_name, last_name, link_to_major) VALUES ('new_member_id', 'John', 'Doe', 'default_major_id') ON CONFLICT (member_id) DO UPDATE SET first_name=excluded.first_name, last_name=excluded.last_name, link_to_major=member.link_to_major;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_0 = execute_queries([\"SELECT member_id, first_name, last_name, link_to_major FROM member WHERE member_id = 'new_member_id';\"], db_name, conn)[0]; \n\n    assert test_pred_query_result_0[0][0] == 'new_member_id', f'Expected member_id to be new_number_id, but found {test_pred_query_result_0[0][0]}'\n    assert test_pred_query_result_0[0][1] == 'John', f'Expected first_name to be John, but found {test_pred_query_result_0[0][1]}'\n    assert test_pred_query_result_0[0][2] == 'Doe', f'Expected last_name to be Doe, but found {test_pred_query_result_0[0][2]}'\n    assert test_pred_query_result_0[0][3] == 'default_major_id', f'Expected link_to_major to be default_major_id, but found {test_pred_query_result_0[0][3]}'\n\n    "]}
{"instance_id": 150, "sol_sql": ["SELECT COUNT(*) AS streak_count, 'April Meeting' AS event_name, 'MST' AS timezone, MIN(min_ts) AS start_date, MAX(max_ts) AS end_date FROM ( SELECT *, the_day - row_number() OVER (ORDER BY the_day)::INT AS streak FROM ( SELECT (event_date::TIMESTAMP AT TIME ZONE 'UTC' AT TIME ZONE 'MST')::date AS the_day , count(*) AS ct, min(event_date) AS min_ts, max(event_date) AS max_ts FROM event WHERE event_name = 'April Meeting' GROUP  BY 1) sub1) sub2 GROUP  BY streak ORDER  BY end_date DESC LIMIT  1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_query_result_1[0][1] == 'April Meeting', 'The event name should be April Meeting.'\n    assert pred_query_result_1[0][2] == 'MST', 'The timezone should be MST.'\n    assert pred_query_result_1[0][0] > 0, 'The streak count should be greater than 0.'\n    test_pred_query_result_1 = execute_queries([\"SELECT MIN(event_date) AS start_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][3] == str(test_pred_query_result_1[0][0]), f'Expected start_date to be {test_pred_query_result_1[0][0]}, but found {pred_query_result_1[0][3]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT MAX(event_date) AS end_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][4] == str(test_pred_query_result_2[0][0]), f'Expected end_date to be {test_pred_query_result_2[0][0]}, but found {pred_query_result_1[0][4]}'\n    \n    "]}
{"instance_id": 151, "sol_sql": ["SELECT DATE_TRUNC('day', to_timestamp(transaction_timestamp / 1000000000.0)), COUNT(*) FROM pitstops GROUP BY 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 152, "sol_sql": ["select id, date, got, gpt from (select lab1.*, row_number() over (partition by lab1.id order by lab1.date) as rn from laboratory lab1 join (select id, date, got, gpt from (select lab.*, row_number() over (partition by lab.id order by lab.date desc) rn from laboratory lab) lab where rn = 1 ) lab2 on lab2.id = lab1.id and lab1.got = lab2.got and lab1.gpt = lab2.gpt) lab where rn = 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 153, "sol_sql": ["WITH constructor_roles AS ( SELECT 18 race_id, 1 constructor_id, false customer_billing, true commander, true agent UNION ALL SELECT 18, 2, true, false, false ), tmp AS ( SELECT n.race_id id, array_agg( ARRAY[ CASE WHEN n.customer_billing = TRUE THEN 'AR (Customer Billing)' END, CASE WHEN n.commander = TRUE THEN 'AP (Commander)' END, CASE WHEN n.agent = TRUE THEN 'AP (Agent)' END ] ) AS finance_array FROM constructor_roles n WHERE n.race_id = 18 AND (n.customer_billing = TRUE or n.commander = TRUE or n.agent = TRUE) GROUP BY race_id ) SELECT id, array_to_string(array(select distinct e from unnest(finance_array) as a(e)), ', ') FROM tmp"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 154, "sol_sql": ["SELECT sub.firstName, jsonb_agg(jsonb_build_object('yearId', sub.yearId, 'classes', sub.classes)) AS years FROM (SELECT s.id, s.firstName, cy.yearId, jsonb_agg(jsonb_build_object('classId', cy.classId)) AS classes FROM users3 s LEFT JOIN classYearStudents cys ON cys.studentId = s.id LEFT JOIN classYears cy ON cy.id = cys.classYearId GROUP BY s.id, cy.yearId) sub GROUP BY sub.firstName, sub.id order by sub.id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 155, "sol_sql": ["WITH RECURSIVE EmpMgrCTE AS (SELECT id, bossid, salary, 0 as EmployeeLevel, id as baseId, salary as baseSalary FROM staff WHERE bossid IS NOT NULL UNION ALL SELECT emp.id, emp.bossid, emp.salary, mgr.EmployeeLevel + 1 as EmployeeLevel, mgr.baseId, mgr.baseSalary FROM staff emp INNER JOIN EmpMgrCTE mgr ON emp.id = mgr.bossid WHERE baseSalary * 2 > mgr.salary) SELECT emp.baseId, emp.baseSalary, EmployeeLevel, emp.id as bossid, emp.salary as bossSalary FROM EmpMgrCTE emp WHERE baseSalary * 2 <= salary order by baseId;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 156, "sol_sql": ["select distinct rarity, first_value(id) over(partition by rarity order by convertedmanacost desc nulls last, edhrecrank desc nulls last, multiverseid asc) from cards;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 157, "sol_sql": ["DROP TABLE IF EXISTS card, account, disp; CREATE TABLE account (account_id INT PRIMARY KEY NOT NULL, district_id INT NOT NULL, frequency TEXT NOT NULL, date DATE NOT NULL); CREATE TABLE disp (disp_id INT PRIMARY KEY NOT NULL, client_id INT NOT NULL, account_id INT NOT NULL, type TEXT NOT NULL, FOREIGN KEY (account_id) REFERENCES account(account_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE OR REPLACE FUNCTION check_account_disp() RETURNS TRIGGER AS $$ BEGIN IF NOT EXISTS (SELECT 1 FROM disp WHERE account_id = OLD.account_id) THEN RAISE EXCEPTION 'Every account has at least one disposition. '; END IF; RETURN OLD; END; $$ LANGUAGE plpgsql; CREATE TRIGGER ensure_account_has_disp BEFORE DELETE ON disp FOR EACH ROW EXECUTE FUNCTION check_account_disp();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    account_results = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 1, 'MONTHLY', '2020-01-01'), (2, 2, 'MONTHLY', '2024-01-01'), (3, 3, 'MONTHLY', '2024-01-01') RETURNING *;\"], db_name, conn)[0]\n    disp_results = execute_queries([\"INSERT INTO disp (disp_id, client_id, account_id, type) VALUES (1, 1, 1, 'OWNER'), (2, 2, 2, 'OWNER'), (3, 3, 3, 'OWNER') RETURNING *;\"],db_name,conn)[0]\n\n    assert len(account_results) == 3, f'Expected 3 rows, but found {len(account_results)} rows'\n    assert account_results[0][0] == 1, f'Expected account_id to be 1, but found {account_results[0][0]}'\n    assert account_results[1][0] == 2, f'Expected account_id to be 2, but found {account_results[1][0]}'\n    assert account_results[2][0] == 3, f'Expected account_id to be 3, but found {account_results[2][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM disp WHERE account_id = 1;\"],db_name,conn)[0]\n    assert disp_results[0][1] == test_pred_query_result_1[0][0], f'Expected disp count for account_id 1 to be {test_pred_query_result_1[0][0]}, but found {disp_results[0][1]}'\n\n\n    "]}
{"instance_id": 158, "sol_sql": ["SELECT COALESCE (ARRAY_AGG (json_build_object ('client_id', client.client_id, 'gender', client.gender, 'birth_date', client.birth_date)) FILTER (WHERE client.client_id IS NOT NULL), ARRAY[]::json[]) AS clients FROM client;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0];\n    assert pred_query_result_1[0][0] != '[null]', 'Expected an empty array instead of [null] when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n    assert isinstance(pred_query_result_1[0][0], list), 'Expected the result to be a list, but found {type(pred_query_result_1[0][0])}'\n    if len(pred_query_result_1[0][0]) == 0:\n        assert pred_query_result_1[0][0] == '[]', 'Expected an empty array when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n\n    if len(pred_query_result_1[0][0]) > 0:\n        for item in pred_query_result_1[0][0]:\n            assert 'client_id' in item, 'Each result should have client_id'\n            assert 'gender' in item, 'Each result should have gender'\n            assert 'birth_date' in item, 'Each result should have birth_date'\n            assert item['client_id'] is not None, 'client_id should not be NULL'\n\n\n    "]}
{"instance_id": 159, "sol_sql": ["\nDELETE FROM transactions_1k a\nUSING transactions_1k b\nWHERE a.productid = '5' \n  AND b.productid = '2'\n  AND a.date = b.date\n  AND a.cardid = b.cardid\n  AND a.gasstationid = b.gasstationid;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM transactions_1k e WHERE EXISTS (SELECT 1 FROM transactions_1k e2 WHERE e.date = e2.date AND e.time = e2.time AND e.cardid = e2.cardid AND e.gasstationid = e2.gasstationid AND e.productid = '2' AND e2.productid = '5') ORDER BY e.date ASC;\"], db_name,conn)[0]\n    assert len(test_pred_query_result_1) == 0, f'Expected 0 row, but found {len(test_pred_query_result_1)}'\n    "]}
{"instance_id": 160, "sol_sql": ["\nWITH RECURSIVE cte AS (\n    SELECT id, \n           amount, \n           amount AS cum_sum, \n           1 AS bucket\n    FROM transfer\n    WHERE id = 1\n    UNION ALL\n    SELECT transfer.id,\n           transfer.amount,\n           CASE \n               WHEN cte.cum_sum + transfer.amount > 20 THEN transfer.amount\n               ELSE cte.cum_sum + transfer.amount\n           END AS cum_sum,\n           CASE \n               WHEN cte.cum_sum + transfer.amount > 20 THEN cte.bucket + 1\n               ELSE cte.bucket\n           END AS bucket\n    FROM cte \n    JOIN transfer ON transfer.id = cte.id + 1\n)\nSELECT id, amount, cum_sum, bucket\nFROM cte \n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = any(row[2] > 20 for row in pred_query_result)\n    assert test_pred_query_result_1 == False, f'Expected not to find any value in cum_sum that is larger than 20, but the result is {test_pred_query_result_1}'\n    ", "\n\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    import random\n    random_num = random.randint(2, len(pred_query_result))\n    diff = pred_query_result[random_num][2] - pred_query_result[random_num-1][2]\n    assert (diff == pred_query_result[random_num][1] or pred_query_result[random_num][2] == pred_query_result[random_num][1]), f'Expected to find the cum_sum equal to value or the difference of values, but found {diff}, {pred_query_result[random_num][1]} and {pred_query_result[random_num][2]}'\n    "]}
{"instance_id": 161, "sol_sql": ["SELECT raceid, laps AS modal_laps FROM (SELECT raceid, laps, COUNT(*) AS freq, MIN(resultid) AS first_occurrence, ROW_NUMBER() OVER (PARTITION BY raceid ORDER BY COUNT(*) DESC, MIN(resultid) ASC) AS rn FROM results GROUP BY raceid, laps) sub WHERE rn = 1 ORDER BY raceid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 162, "sol_sql": ["SELECT CASE WHEN t1.table_name IS NULL THEN 'extra' ELSE 'missing' END AS kind, table_name FROM required_tables t1 FULL JOIN (SELECT table_name FROM information_schema.tables WHERE  table_schema='public') t2 USING (table_name) WHERE (t1.table_name IS NULL OR t2.table_name IS NULL);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 163, "sol_sql": ["ALTER TABLE dependency DROP CONSTRAINT dependency_match1_stage1_fkey, DROP CONSTRAINT dependency_match2_stage2_fkey;", "ALTER TABLE dependency ADD CONSTRAINT dependency_match1_stage1_fkey FOREIGN KEY (match1, stage1) REFERENCES match (id, stage) ON DELETE CASCADE ON UPDATE CASCADE, ADD CONSTRAINT dependency_match2_stage2_fkey FOREIGN KEY (match2, stage2) REFERENCES match (id, stage) ON DELETE CASCADE ON UPDATE CASCADE;", "UPDATE match SET stage = stage + 1 WHERE id = 'match1';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries([\"SELECT * FROM match WHERE id = 'match1';\"], 'european_football_2', conn)[0]\n    assert test_pred_query_result[0][1] == 2, 'The update does not happen.'\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM dependency;\"], 'european_football_2', conn)[0]\n    assert test_pred_query_result_1[0][1] == 2, 'The update does not happen in dependency.'\n    "]}
{"instance_id": 164, "sol_sql": ["create index idx_a on superhero_events (start_time, end_time) include (event_id, hero_id);", "SELECT * from superhero_events WHERE start_time >= Now()::timestamp - INTERVAL '3 days' AND end_time < now()+'5 hours'::interval ORDER BY CASE WHEN now()+'5 hours'::interval > Now()::timestamp AND start_time < Now()::timestamp THEN 1 WHEN start_time < Now()::timestamp THEN 2 ELSE 3 END;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 165, "sol_sql": ["with hero_attribute(hero_id, attribute_id, attribute_value) as ( values (1, 1, 80), (2, 1, 75), (3, 1, 95), (4, 1, 85), (5, 1, 90), (6, 1, 70) ), running as ( select hero_id, sum(attribute_value) over (order by hero_id rows between 2 preceding and 3 following) from hero_attribute) select sum from running where (hero_id-1) % 2 = 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 166, "sol_sql": ["select id, name, jsonb_path_query_array(skills::jsonb,'$[*].description') as skill from player_skills;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    for row in pred_query_result:\n        if row[0] == 1:\n            skill = row[2]\n            assert skill == [\"Passing\", \"Shooting\"], \"ID 1 returns wrong skills.\"\n        elif row[0] == 2:\n            skill = row[2]\n            assert skill == [\"Defending\", \"Tackling\"], \"ID 2 returns wrong skills.\"\n        else:\n            skill = row[2]\n            assert skill == [], \"ID 3 returns wrong skills.\"\n    "]}
{"instance_id": 167, "sol_sql": ["select (select tt.value from json_array_elements(t.events) as tt where tt->>'id' = '2') FROM match_events as t;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert pred_query_result[0][0] == {\"id\": 2, \"description\": \"Yellow Card\"}, \"Wrong result 1.\"\n    assert pred_query_result[1][0] == {\"id\": 2, \"description\": \"Goal\"}, \"Wrong result 2.\"\n    "]}
{"instance_id": 168, "sol_sql": ["SELECT DISTINCT ON (examination_year) c, \"ANA Pattern\", examination_year FROM (SELECT COUNT(\"ANA Pattern\") AS c, \"ANA Pattern\", EXTRACT(YEAR FROM \"Examination Date\") AS examination_year FROM examination WHERE EXTRACT(YEAR FROM \"Examination Date\") BETWEEN 1993 AND 1996 GROUP BY EXTRACT(YEAR FROM \"Examination Date\"), \"ANA Pattern\") AS sub ORDER BY examination_year, c DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 4, f'Expected 4 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": 169, "sol_sql": ["WITH player_names AS (SELECT 1 AS source, ROW_NUMBER() OVER (ORDER BY player_name) AS row_number, CONCAT(player_name, '(', LEFT(birthday, 4), ')') AS dest FROM player_table), birth_year_summary AS (SELECT 2 AS source, ROW_NUMBER() OVER (ORDER BY COUNT(*), LEFT(birthday, 4)) AS row_number, CONCAT('There are a total of ', COUNT(*), ' player', CASE WHEN COUNT(*) > 1 THEN 's' ELSE '' END, ' born in ', LEFT(birthday, 4), '.') AS dest FROM player_table GROUP BY LEFT(birthday, 4)) SELECT dest FROM (SELECT * FROM player_names UNION ALL SELECT * FROM birth_year_summary) AS combined_results ORDER BY source, row_number;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    for i in range(len(sol_query_result)):\n        assert pred_query_result[i] == sol_query_result[i], 'Wrong order.' \n        return\n    "]}
{"instance_id": 170, "sol_sql": ["SELECT rs.raceId as race_id, (SELECT string_agg(constructorId::TEXT, ',' ORDER BY res.resultId) FROM results res WHERE res.raceId = rs.raceId) as constructor_ids, (SELECT string_agg(p.stop::TEXT, ', ' ORDER BY p.raceId) FROM pitstops p WHERE rs.raceId = p.raceId) AS stops FROM races rs"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 171, "sol_sql": ["SELECT r.* FROM route r WHERE EXISTS(SELECT 1 FROM route_detail rd WHERE r.id = rd.route_id AND rd.visit_status = 5) AND NOT EXISTS(SELECT 1 FROM route_detail rd INNER JOIN route_event e ON rd.id = e.route_detail_id WHERE r.id = rd.route_id AND e.event_type = 3);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 2, f\"Expected 2 rows in pred_result but found {len(pred_sqls_result)} rows.\"\n    assert pred_sqls_result[0][0] == 4, f'Expected route 4, but found route {pred_sqls_result[0][0]}'\n    assert pred_sqls_result[1][0] == 5, f'Expected route 5, but found route {pred_sqls_result[1][0]}'"]}
{"instance_id": 172, "sol_sql": ["CREATE OR REPLACE FUNCTION update_team_attributes_eff_to() RETURNS TRIGGER AS $$ BEGIN UPDATE team_attributes SET eff_to = subquery.next_date FROM ( SELECT id, team_api_id, COALESCE(LEAD(TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE, 1) OVER (PARTITION BY team_api_id ORDER BY TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE ASC), TO_DATE('6000-00-00', 'YYYY-MM-DD')) - 1 AS next_date FROM team_attributes ) AS subquery WHERE team_attributes.team_api_id = subquery.team_api_id AND team_attributes.id = subquery.id; RETURN NEW; END; $$ LANGUAGE plpgsql; CREATE OR REPLACE TRIGGER after_insert_team_attributes AFTER INSERT ON team_attributes FOR EACH ROW EXECUTE PROCEDURE update_team_attributes_eff_to();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"INSERT INTO team_attributes (team_api_id, date) VALUES (9930, '2010-09-08 00:00:00'), (9930, '2014-09-08 00:00:00'), (9930, '2015-09-08 00:00:00')\"], db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT date, eff_to FROM team_attributes WHERE team_api_id = 9930;\"], db_name, conn)[0]\n    assert set((str(date), str(eff_to)) for date, eff_to in pred_sqls_result) == set((str(date), str(eff_to)) for date, eff_to in [(\"2014-09-08 00:00:00\", \"2014-09-18\"), (\"2015-09-08 00:00:00\", \"2015-09-09\"), (\"2010-02-22 00:00:00\", \"2010-09-07\"), (\"2010-09-08 00:00:00\", \"2014-09-07\"), (\"2014-09-19 00:00:00\", \"2015-09-07\"), (\"2015-09-10 00:00:00\", \"5999-12-31\")]), f\"Expected pred_result and sol_result to be the same, but pred_result is {pred_sqls_result} and sol_result is [('2014-09-08 00:00:00', '2014-09-18'), ('2015-09-08 00:00:00', '2015-09-09'), ('2010-02-22 00:00:00', '2010-09-07'), ('2010-09-08 00:00:00', '2014-09-07'), ('2014-09-19 00:00:00', '2015-09-07'), ('2015-09-10 00:00:00', '5999-12-31')].\""]}
{"instance_id": 173, "sol_sql": ["select position, array_agg(driverid) as driverids from results where driverid not in (select max(driverid) from results group by position) group by position order by position;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 174, "sol_sql": ["DO $do$ DECLARE _max_depth int := (SELECT max(length(id::text)) - 1 FROM superhero2); _depth int; BEGIN FOR _depth IN REVERSE _max_depth .. 1 LOOP UPDATE superhero2 p SET color = c.color FROM (SELECT parent_id AS parent, CASE WHEN min(color) = max(color) THEN min(color) ELSE 'gray' END AS color FROM superhero2 WHERE length(id::text) = _depth + 1 GROUP BY parent_id) c WHERE p.id = c.parent AND p.color IS DISTINCT FROM c.color; END LOOP; END $do$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    pred_sqls_result = execute_queries([\"select * from superhero2;\"], db_name, conn)[0]\n    execute_queries(sol_sqls, db_name, conn)\n    sol_sqls_result = execute_queries([\"select * from superhero2;\"], db_name, conn)[0]\n    assert set(pred_sqls_result) == set(sol_sqls_result), f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 175, "sol_sql": ["SELECT * \nFROM (\n  SELECT gender_id, COUNT(*) as cnt1 \n  FROM superhero \n  WHERE gender_id IN (1, 2) \n  GROUP BY gender_id\n) AS g1\nFULL OUTER JOIN (\n  SELECT alignment_id, COUNT(*) as cnt2 \n  FROM superhero \n  WHERE alignment_id IN (1, 2) \n  GROUP BY alignment_id\n) AS a1\nON g1.gender_id = a1.alignment_id\nWHERE COALESCE(g1.gender_id, a1.alignment_id) IN (1, 2);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 176, "sol_sql": ["SELECT artist, setcode, COUNT(setcode) AS counter\nFROM cards\nGROUP BY artist, setcode\nORDER BY MAX(COUNT(*)) OVER (PARTITION BY artist) DESC, artist, COUNT(*) DESC, setcode;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": 177, "sol_sql": ["SELECT match_id, current_lineup, next_lineup, (SELECT COUNT(DISTINCT arr) FROM unnest(current_lineup) arr WHERE arr = ANY(next_lineup)) AS overlapping_players FROM match_lineups;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)       \n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 178, "sol_sql": ["SELECT rec.circuitid, rec.name FROM circuit_json, jsonb_to_record(circuit_id_name::jsonb) AS rec(circuitid int, name text);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)       \n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 179, "sol_sql": ["INSERT INTO hero_attribute_bifurcation (hero_id, attribute_id, attribute_chunk, is_bifurcated) SELECT ha.hero_id,\n       ha.attribute_id,\n       CASE \n           WHEN (g.c + 1) * 50 > ha.attribute_value \n           THEN ha.attribute_value - g.c * 50\n           ELSE 50\n       END AS attribute_chunk,\n       CAST(ha.attribute_value > 50 AS integer) AS is_bifurcated\nFROM hero_attribute AS ha\nCROSS JOIN LATERAL generate_series(0, (ha.attribute_value - 1) / 50) AS g(c)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT attribute_chunk, is_bifurcated FROM hero_attribute_bifurcation WHERE hero_id = 1 and attribute_id = 1;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 50, f'Expected attribute_chunk to match, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[0][1] == 1, f'Expected is_bifurcated to match, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[1][0] == 30, f'Expected attribute_chunk to match, but found {test_pred_query_result_1[1][0]}'\n    assert test_pred_query_result_1[1][1] == 1, f'Expected name to match, but found {test_pred_query_result_1[1][1]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT attribute_chunk, is_bifurcated FROM hero_attribute_bifurcation WHERE hero_id = 748 and attribute_id = 6;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 45, f'Expected attribute_chunk to match, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[0][1] == 0, f'Expected is_bifurcated to match, but found {test_pred_query_result_1[0][1]}'\n"]}
{"instance_id": 180, "sol_sql": ["SELECT y.district_id, \n       array_agg(y.loan_id) FILTER (WHERE y.status IN ('A', 'B')) AS type_A_B, \n       array_agg(y.loan_id) FILTER (WHERE y.status = 'C') AS type_C\nFROM (\n  SELECT x.district_id, l.loan_id, l.status\n  FROM loan l\n  JOIN account x ON l.account_id = x.account_id\n) y\nGROUP BY 1\nORDER BY 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f'Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}'\n"]}
{"instance_id": 181, "sol_sql": ["WITH labeled_ends AS (SELECT lag(sa.ts) OVER (PARTITION BY sa.superhero_id, sa.activity_code ORDER BY sa.ts) = sa.ts - interval '5' minute IS NOT TRUE AS begins_period, sa.ts, lead(sa.ts) OVER (PARTITION BY sa.superhero_id, sa.activity_code ORDER BY sa.ts) = sa.ts + interval '5' minute IS NOT TRUE AS ends_period, sa.superhero_id, sa.activity_code FROM superhero_activities sa), periods AS (SELECT labeled_ends.ts, CASE WHEN labeled_ends.ends_period THEN labeled_ends.ts ELSE lead(labeled_ends.ts) OVER (PARTITION BY labeled_ends.superhero_id, labeled_ends.activity_code ORDER BY labeled_ends.ts) END AS period_end, labeled_ends.superhero_id, labeled_ends.activity_code, labeled_ends.begins_period FROM labeled_ends WHERE labeled_ends.begins_period OR labeled_ends.ends_period) SELECT tstzrange(periods.ts, periods.period_end, '[]') AS valid_interval, periods.superhero_id, periods.activity_code FROM periods WHERE periods.begins_period ORDER BY periods.superhero_id, periods.activity_code, periods.ts;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 182, "sol_sql": ["SELECT COUNT(DISTINCT tournament_id) FROM card_matches WHERE player1_id IN (SELECT id FROM card_players WHERE type = 'Pro') OR player2_id IN (SELECT id FROM card_players WHERE type = 'Pro')"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 183, "sol_sql": ["SELECT league_id, season, STRING_AGG(DISTINCT id::TEXT, ',') as match_ids, STRING_AGG(DISTINCT date:: TEXT, ',') AS match_dates FROM match WHERE season IS NOT NULL AND league_id IS NOT NULL AND date IS NOT NULL GROUP BY league_id, season order by league_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 184, "sol_sql": ["SELECT row_id, MAX(CASE WHEN col_name = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' THEN value ELSE NULL END) AS card1, MAX(CASE WHEN col_name = '56f4935b-f6c5-59b9-88bf-9bcce20247ce' THEN value ELSE NULL END) AS card2, MAX(CASE WHEN col_name = '6d268c95-c176-5766-9a46-c14f739aba1c' THEN value ELSE NULL END) AS card3 FROM (SELECT uuid as col_name, text as value, ROW_NUMBER() OVER (PARTITION BY uuid ORDER BY id) as row_id FROM ruling) r group by row_id order by row_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 185, "sol_sql": ["\nSELECT c.*\nFROM cards_info c\nWHERE NOT EXISTS (\n    SELECT * \n    FROM card_choice cc\n    WHERE cc.non_valid_cards::jsonb @> to_jsonb(c.id)\n    AND cc.card_id = c.id\n);\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    for i in range(len(pred_query_result)):\n        sql_query = f\"SELECT * FROM card_choice cc WHERE cc.card_id = {pred_query_result[i][0]} AND cc.non_valid_cards::jsonb @> to_jsonb({pred_query_result[i][0]});\"\n        test_pred_query_result_1 = perform_query_on_postgresql_databases(sql_query, db_name)[0]\n        assert test_pred_query_result_1 == [], f'Expected to find nothing, but found {test_pred_query_result_1}'\n     ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    "]}
{"instance_id": 186, "sol_sql": ["\nWITH RECURSIVE RCTE_NODES AS (\n  SELECT\n    uuid\n  , card_name AS name\n  , uuid as root_uuid\n  , card_name as root_name\n  , 1 as lvl\n  , ARRAY[]::uuid[] as children\n  , true as has_next\n  FROM card_type\n  WHERE parent_uuid IS null\n\n  UNION ALL\n\n  SELECT\n    cat.uuid\n  , cat.card_name AS name\n  , cte.root_uuid\n  , cte.root_name\n  , cte.lvl+1\n  , cte.children || cat.uuid\n  , (exists(select 1 from card_type cat2 where cat2.parent_uuid = cat.uuid))\n  FROM RCTE_NODES cte\n  JOIN card_type cat\n    ON cat.parent_uuid = cte.uuid\n)\nSELECT root_uuid as uuid, root_name as name\n, array_agg(children) as children\nFROM RCTE_NODES\nWHERE has_next = false\nGROUP BY root_uuid, root_name\nORDER BY root_uuid;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    for i in range(len(pred_query_result)):\n        sql_query = f\"SELECT parent_uuid FROM card_type WHERE card_name = '{pred_query_result[0][1]}';\"\n        test_pred_query_result_1 = perform_query_on_postgresql_databases(sql_query, db_name)[0][0]\n        assert test_pred_query_result_1[0] is None, f'Expected to find nothing, but found {test_pred_query_result_1}'\n     ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    "]}
{"instance_id": 187, "sol_sql": ["SELECT d.the_day AS \"Date\", COUNT(DISTINCT e.event_id) AS \"Number of Events\", AVG(b.avg_remaining) AS \"Avg Remaining Budget\" FROM (SELECT ts::date AS the_day FROM generate_series('2020-01-01'::timestamp, '2020-03-31'::timestamp, '1 day'::interval) AS ts) d LEFT JOIN \"event\" e ON e.event_date::date = d.the_day AND e.status IN ('Open', 'Closed') LEFT JOIN (SELECT link_to_event, SUM(remaining) as avg_remaining FROM budget GROUP BY link_to_event) b ON b.link_to_event = e.event_id GROUP BY d.the_day ORDER BY d.the_day;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    assert len(pred_query_result_1) == 91, f'Expected 91 rows, but found {len(pred_query_result_1)} rows'\n    assert str(pred_query_result_1[0][0]) == '2020-01-01', f'Expected the first date to be 2020-01-01, but found {pred_query_result_1[0][0]}'\n    assert str(pred_query_result_1[-1][0]) == '2020-03-31', f'Expected the last date to be 2020-03-31, but found {pred_query_result_1[-1][0]}'\n    assert pred_query_result_1[13][1] == 2, f'Expected the number of events on 2020-01-14 day to be 2, but found {pred_query_result_1[13][1]}'\n    assert pred_query_result_1[27][2] > 0, f'Expected the average remaining budget on 2020-01-28 day to be greater than 0, but found {pred_query_result_1[27][2]}'\n    assert pred_query_result_1[41][1] == 1, f'Expected the number of events on 2020-02-11 day to be 1, but found {pred_query_result_1[41][1]}'\n    assert pred_query_result_1[33][2] is None or pred_query_result_1[33][2] >= 0, f'Expected the average remaining budget on 2020-02-02 day to be 0 or NULL, but found {pred_query_result_1[33][2]}'\n\n    "]}
{"instance_id": 188, "sol_sql": ["SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1997 THEN trans.amount ELSE 0 END) AS a1997, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1998 THEN trans.amount ELSE 0 END) AS a1998 FROM trans WHERE trans.date >= '1997-01-01' AND trans.date < '1999-01-01' GROUP BY month ORDER BY 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    print(pred_query_result_1)\n    assert len(pred_query_result_1) == 12, f'Expected 12 rows (one for each month), but found {len(pred_query_result_1)} rows'\n    assert pred_query_result_1[0][0] == '01', 'The first month should be January (01).'\n    assert pred_query_result_1[-1][0] == '12', 'The last month should be December (12).'\n    assert pred_query_result_1[0][2] is not None, 'The sum of transactions for January 1998 should not be None.'\n    test_pred_query_result_1 = execute_queries([\"SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(trans.amount) AS total FROM trans WHERE EXTRACT(YEAR FROM trans.date) = 1997 GROUP BY month ORDER BY month;\"], db_name, conn)[0]\n    assert pred_query_result_1[0][1] == test_pred_query_result_1[0][1], f'Expected the sum of transactions for January 1997 to be {test_pred_query_result_1[0][1]}, but found {pred_query_result_1[0][1]}.'\n\n    "]}
{"instance_id": 189, "sol_sql": ["SELECT DISTINCT * FROM circuits c WHERE EXISTS (SELECT 1 FROM (SELECT ST_SetSRID(ST_MakePoint(2.76083, 101.73800), 4326)::geography AS point UNION ALL SELECT ST_SetSRID(ST_MakePoint(26.03250, 50.51060), 4326)::geography) points WHERE ST_DWithin(ST_SetSRID(ST_MakePoint(c.lng, c.lat), 4326)::geography, points.point, 1000000));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    assert len(pred_query_result_1) > 0, 'Expected at least one circuit within the given distance, but found none.'\n    assert pred_query_result_1[0][2] == 'Hungaroring', 'Expected the first circuit to be Hungaroring, but found a different one.'\n    assert pred_query_result_1[2][2] == 'Zeltweg', 'Expected the first circuit to be Zeltweg, but found a different one.'\n    test_pred_query_result_1 = execute_queries([\"SELECT DISTINCT * FROM circuits c WHERE EXISTS (SELECT 1 FROM (SELECT ST_SetSRID(ST_MakePoint(2.76083, 101.73800), 4326)::geography AS point UNION ALL SELECT ST_SetSRID(ST_MakePoint(26.03250, 50.51060), 4326)::geography) points WHERE ST_DWithin(ST_SetSRID(ST_MakePoint(c.lng, c.lat), 4326)::geography, points.point, 1000000));\"], db_name, conn)[0]\n    assert pred_query_result_1[0][0] == test_pred_query_result_1[0][0], f'Expected circuit count to match, but found {pred_query_result_1[0][0]} instead of {test_pred_query_result_1[0][0]}.'\n\n    "]}
{"instance_id": 190, "sol_sql": ["SELECT resultid FROM results where driverid in (3, 4) order by resultid DESC LIMIT 10"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": 191, "sol_sql": ["CREATE OR REPLACE FUNCTION words_get_uid(in_social integer, in_sid text) RETURNS integer AS $func$ SELECT uid FROM words_social WHERE social = in_social AND sid = in_sid; $func$ LANGUAGE sql IMMUTABLE;", "CREATE OR REPLACE FUNCTION words_get_chat(in_gid integer, in_uid integer) RETURNS TABLE (out_mine integer, out_msg text) AS $func$ SELECT CASE WHEN c.uid = in_uid THEN 1 ELSE 0 END, c.msg FROM words_chat c JOIN words_games g USING (gid) JOIN words_users opponent ON (opponent.uid IN (g.player1, g.player2) AND opponent.uid <> in_uid) WHERE c.gid = in_gid AND (c.uid = in_uid OR NOT opponent.muted) ORDER BY c.created ASC; $func$ LANGUAGE sql;", "SELECT words_get_chat(10, words_get_uid(100, 'abc')) AS nice_user;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 192, "sol_sql": ["WITH cte AS (SELECT driverid, points, (points * 100) as earnings FROM driverstandings) SELECT driverid, points, earnings, CASE WHEN earnings > 5000 THEN earnings * 0.2 WHEN earnings > 3000 THEN earnings * 0.15 ELSE null END AS bonus FROM cte"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count_price_times = sum(sql.lower().count('points * 100') for sql in pred_sqls)\n    assert count_price_times <= 3, f'Expected at most 3 occurrences of \"price * 100\" in the query, but got {count_price_times}.'\n"]}
{"instance_id": 193, "sol_sql": ["with dataset as (\n  SELECT \n      date,\n      COUNT(*) as rows_added\n  FROM\n      team_attributes\n  WHERE \n      date between '2010-01-01 00:00:00'\n      AND '2015-12-31 00:00:00'\n  GROUP BY \n      date\n )\nSELECT\n    COUNT(*) as total_days_in_result_set,\n    COUNT(DISTINCT rows_added) as total_days_w_distinct_record_counts,\n    COUNT(*) - COUNT(DISTINCT rows_added) as total_days_w_duplicate_record_counts,\n    COUNT(*) - COUNT(DISTINCT date) as duplicate_dates\nFROM dataset"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 194, "sol_sql": ["insert into card_counters (card_name, counters) values ('Lightning Bolt', array[2,0,2,1]) on conflict (card_name) do update set counters = (select array_agg(e1 + e2) from unnest(card_counters.counters, excluded.counters) as u(e1, e2))"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries([\"SELECT * FROM card_counters;\"], db_name, conn)[0]\n    sol_sqls_result = [('Lightning Bolt', [3, 3, 3, 1])]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 195, "sol_sql": ["CREATE OR REPLACE FUNCTION f_special_running_sum() RETURNS TABLE(id int, result numeric(10,6)) LANGUAGE plpgsql AS $func$ DECLARE t record; BEGIN DROP TABLE IF EXISTS pg_temp.result; CREATE TEMP TABLE result (id int, trx int, result float8) ON COMMIT DROP; FOR t IN TABLE sales_transactions ORDER BY id LOOP INSERT INTO result(id, trx, result) SELECT t.id, t.trx, (COALESCE(sum(r.trx + r.result), 0) + t.trx) * t.event FROM result r; END LOOP; RETURN QUERY SELECT r.id, r.result::numeric(10,6) FROM result r; END $func$;", "SELECT * FROM f_special_running_sum();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 196, "sol_sql": ["WITH cte_funding_count AS (SELECT fundingtype, COUNT(*) AS count FROM schools GROUP BY fundingtype), p as( SELECT fundingtype,  count,  ROUND(count*100./(SELECT SUM(count) FROM cte_funding_count),0) AS percent FROM cte_funding_count ) select fundingtype, count, case(row_number() over(order by percent desc)) when 1  then 100 - sum(percent) over(order by percent desc rows between 1 following and unbounded following)  else percent end pp from p"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    total = sum([item[2] for item in pred_sqls_result])\n    assert total == 100, f'Expected the total percentage is 100, but found {total}'"]}
{"instance_id": 197, "sol_sql": ["WITH RankedLabs AS (SELECT lab.date AS firstActivity, pat.ID as id, ROW_NUMBER() OVER (PARTITION BY pat.id ORDER BY lab.date ASC) AS rn FROM patient pat JOIN laboratory lab ON lab.id = pat.id AND lab.date <= pat.description AND lab.date > pat.\"First Date\" WHERE pat.sex = 'F') SELECT firstActivity, id FROM RankedLabs WHERE rn = 1 ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": 198, "sol_sql": ["CREATE or replace FUNCTION f_arr_except_arr(a1 text[], a2 text[])  RETURNS text[] LANGUAGE SQL IMMUTABLE PARALLEL SAFE BEGIN ATOMIC SELECT ARRAY (SELECT unnest(a1) EXCEPT ALL SELECT unnest(a2)); END;", "SELECT id, f_arr_except_arr(string_to_array(c.keywords, ',')::text[], s.RemoveKeywords) AS updated_keywords FROM  cards c JOIN (SELECT id, RemoveKeywords FROM SelectQuery) s USING (id) order by id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": 199, "sol_sql": ["SELECT week_start, count(*) AS count, AVG(\"CL\") AS cl, AVG(\"C\") AS c FROM (SELECT generate_series('2021-01-07 00:00:00'::timestamp, '2022-01-06 23:59:59'::timestamp, '7 days'::interval) AS week_start) gs INNER JOIN \"Experiment\" e ON e.\"TIMESTAMP\" >= gs.week_start AND e.\"TIMESTAMP\" < gs.week_start + '7 days'::interval GROUP BY week_start ORDER BY week_start ASC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}