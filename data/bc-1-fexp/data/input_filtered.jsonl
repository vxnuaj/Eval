{"instance_id": 0, "selected_database": "financial", "query": "In the financial database, we have a table named 'order' that records details about orders given to clients. Each order is associated with an order_id and has attributes such as account_id, bank_to, account_to, and amount. We need to find all accounts that have placed at least two orders such that the difference between the highest and lowest amount for those orders exceeds 12000. This query aims to find such accounts, but the initial attempt produced incorrect results.", "error_sql": ["SELECT account_id, MAX(payments) AS max_payment, MIN(payments) AS min_payment FROM loan GROUP BY account_id HAVING COUNT(account_id) > 1 AND (MAX(payments) - MIN(payments)) > 2;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 1, "selected_database": "codebase_community", "query": "I have a table named 'comments' in the 'codebase_community' database with a column 'CreationDate' of type 'datetime'. I want to extract only the 'hh:mm:ss' part from this column. My desired result should look like this:\n\n\n0:00:00\n10:00:00\n04:00:00\n\n\nHowever, when I tried to use the following SQL query, it didn't give me the expected result:\n\nsql\nSELECT CreationDate::time FROM comments;\n\n\nThis query returns the time part but includes leading zeros, which I don't want. How can I modify my query to achieve the desired result?", "error_sql": ["SELECT CreationDate::time FROM comments;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 2, "selected_database": "financial", "query": "I'm exploring triggers and want to create one that fires after an Update event on a `status` column in the `loan` table. The column contains text values representing loan statuses, so the user may update the loan status. I want the trigger function to calculate the number of loans with a specific status 'A' for a certain account. Then update `total_loan_count` in a `loan_summary` table. Here is my trigger (which is not working and I want to figure out why):", "error_sql": ["CREATE OR REPLACE FUNCTION total_loans()\n    RETURNS TRIGGER \n    AS $$ \n    BEGIN \n        UPDATE loan_summary \n        SET total_loan_count = (SELECT COUNT(CASE WHEN status = 'A' THEN 1 END) FROM loan WHERE loan_summary.account_id = loan.account_id) WHERE account_id = NEW.account_id; RETURN NEW; \n    END; \n    $$ LANGUAGE plpgsql;", "\n    CREATE TRIGGER tr_total_loans AFTER UPDATE OF status FOR EACH ROW EXECUTE PROCEDURE total_loans();\n    "], "sol_sql": [], "preprocess_sql": ["DROP TABLE IF EXISTS loan_summary;", "CREATE TABLE loan_summary (account_id INT PRIMARY KEY, total_loan_count INT);", "INSERT INTO loan_summary (account_id, total_loan_count) SELECT l.account_id, COUNT(*) FROM loan l WHERE l.status = 'A' GROUP BY l.account_id;"], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 3, "selected_database": "european_football_2", "query": "In the context of managing team attributes in the European Football database, a user attempted to add a new value 'Very Fast' to an existing ENUM type for 'buildupplayspeedclass' in the 'team_attributes' table. The user tried an approach: renaming the existing ENUM and creating a new one with the additional value, and switch the data type in place. The approach resulted in locks that caused application downtime, especially considering the table's size in the millions of rows. The user is seeking a solution that avoids such downtime, possibly by considering a different approach than using ENUMs.", "error_sql": ["ALTER TYPE buildupplayspeedclass RENAME TO buildupplayspeedclass_old;", "CREATE TYPE buildupplayspeedclass AS ENUM ('Slow', 'Balanced', 'Fast', 'Very Fast');", "ALTER TABLE Team_Attributes ALTER COLUMN buildupplayspeedclass SET DATA TYPE buildupplayspeedclass USING buildupplayspeedclass::text::buildupplayspeedclass;", "DROP TYPE buildupplayspeedclass;"], "sol_sql": [], "preprocess_sql": ["CREATE TYPE buildupplayspeedclass_enum AS ENUM ('Balanced', 'Fast', 'Slow');", "\n    ALTER TABLE team_attributes\n    ALTER COLUMN buildupplayspeedclass\n    TYPE buildupplayspeedclass_enum\n    USING buildupplayspeedclass::buildupplayspeedclass_enum;"], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 4, "selected_database": "student_club", "query": "In the student_club database, I created a unique index on the `event` table using the following queries 'CREATE UNIQUE INDEX unique_name ON event(event_name, event_date) where event_name is not null; CREATE UNIQUE INDEX unique_location ON event(location, event_date) where location is not null;'. However, when I attempt to insert a new record using an UPSERT operation using the query 'insert into event (event_id, event_name, location, event_date) values('test1', 'test_name', 'test_location', 'test_date')on conflict (event_name, location, event_date) do update set event_id = 'test1', event_name = 'test_name', location = 'test_location', event_date = 'test_date'', I encounter an error stating that there is no unique or exclusion constraint matching the ON CONFLICT specification.", "error_sql": ["CREATE UNIQUE INDEX unique_name ON event(event_name, event_date) where event_name is not null;CREATE UNIQUE INDEX unique_location ON event(location, event_date) where location is not null;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 5, "selected_database": "debit_card_specializing", "query": "In the following SQL, how could I make the `RETURNING` clause join to something else and return the joined row(s)? Here it only returns the row from `transactions_1k` that was updated, but I'd like it to return that row joined to something in another table, e.g. joined to `customers` tables and get both `transactions_1k.transactionid` and `customers.Segment` columns.", "error_sql": ["\n    UPDATE transactions_1k \n    SET Amount = 100 \n    FROM ( SELECT TransactionID FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub \n    WHERE transactions_1k.TransactionID = sub.TransactionID RETURNING *;\n    "], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 6, "selected_database": "codebase_community", "query": "I have a query that calculates the number of referrals each user has made. However, I want to count a referral only if the referred user has activated their premium account. How can I achieve this?", "error_sql": ["SELECT users.Id, COUNT(posts.Id) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 7, "selected_database": "codebase_community", "query": "I want to drop the 'users' table from the 'codebase_community' database. However, when I attempt to drop the table using the SQL command `DROP TABLE IF EXISTS users;`, I encounter an error message stating: 'cannot drop table users because other objects depend on it'. This issue arises because the 'users' table is referenced by foreign keys in other tables such as 'badges', 'comments', 'postHistory', 'posts', and 'votes'. I am seeking a solution to drop the 'users' table without having to remove all dependent tables or data.", "error_sql": ["DROP TABLE IF EXISTS users;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 8, "selected_database": "student_club", "query": "In database student_club, there is a set of users. A student can have multiple users, but ref1 and ref2 might be alike and can therefore link users together. ref1 and ref2 does not overlap, one value in ref1 does not exist in ref2.  A user can own multiple assets. I want to \"merge\" users that has one or more refs alike and then count how many assets they own together. There could be missing entries in the user table, in that case I just want to propagate the owner into ref2 and set the asset_count and asset_ids.", "error_sql": ["SELECT  ARRAY_AGG(DISTINCT u.id) AS ids, ARRAY_AGG(DISTINCT u.username) AS usernames, ARRAY_AGG(DISTINCT u.ref1) AS refs1, ARRAY_AGG(DISTINCT u.ref2) AS refs2,  COUNT(DISTINCT a.id) AS asset_count FROM assets a JOIN users u ON a.owner = u.ref1 OR a.owner = u.ref2 GROUP BY a.owner ORDER BY MIN(a.id);"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE assets (id serial, name text, owner text, PRIMARY KEY(id));", "CREATE TABLE users (id serial, username text, ref1 text, ref2 text, PRIMARY KEY(id));", "INSERT INTO assets (name, owner) VALUES ('#1', 'a'), ('#2', 'b'), ('#3', 'c'), ('#4', 'a'), ('#5', 'c'), ('#6', 'd'), ('#7', 'e'), ('#8', 'd'), ('#9', 'a'), ('#10', 'a'), ('#11', 'z');", "INSERT INTO users (username, ref1, ref2) VALUES ('bobo', 'a', 'd'), ('toto', 'b', 'e'), ('momo', 'c', 'd'), ('lolo', 'a', 'f'), ('popo', 'c', 'f');"], "clean_up_sql": ["drop table if exists users;", "drop table if exists assets;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 9, "selected_database": "student_club", "query": "I am trying to compare the number of attendees for each event between two different tables: 'attendance' and 'budget'. I want to find events where the number of attendees in the 'attendance' table does not match the number of attendees recorded in the 'budget' table. My query follows this structure:", "error_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ) SELECT CTE.link_to_event, CTE.count AS newCount, budget.count AS oldCount FROM budget JOIN CTE ON budget.link_to_event = CTE.link_to_event WHERE budget.count != CTE.count;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 10, "selected_database": "student_club", "query": "In the student_club database, we have a scenario where a member can attend multiple events, and an event can have multiple attendees. However, a member can only attend an event once. If a member attempts to attend the same event again, the system should update the attendance record with new information, such as status attend. The current approach is to use an INSERT statement, but it fails when the member already has an attendance record for the event. We need to implement an insert statement that updates the existing record if a conflict occurs based on the combination of member_id and event_id.", "error_sql": ["INSERT INTO attendance VALUES ('recEVTik3MlqbvLFi', 'rec280Sk7o31iG0Tx', 1)"], "sol_sql": [], "preprocess_sql": ["ALTER TABLE attendance ADD COLUMN attend INTEGER DEFAULT 0;"], "clean_up_sql": ["ALTER TABLE attendance DROP COLUMN attend;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 11, "selected_database": "financial", "query": "In the financial database, there is a need to convert the data from a `BIGINT` column to a `TIMESTAMP` column. The `date` column in the `account` table is currently stored as a `BIGINT` representing the date in the format YYMMDD. The goal is to update this column to a `TIMESTAMP` type to store the date and time information.", "error_sql": ["\n    UPDATE account\n    SET date__timestamp = date__bigint::timestamp;\n    "], "sol_sql": [], "preprocess_sql": ["\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE BIGINT\n    USING to_char(date, 'YYYYMMDD')::bigint;\n    "], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 12, "selected_database": "card_games", "query": "In the card_games database, there is a table named 'cards'. Each card is uniquely identified by a id and includes details about artists and bordercolors. The user wants to group the cards by their 'artist' attribute to get a distinct result for each group. However, when the user tries to use the following SQL query to achieve this, it results in an error or incorrect output: sql SELECT * FROM cards GROUP BY artist; The user understands that this query is incorrect because it does not group by all the columns that need to be shown. The user is seeking a solution to this problem.", "error_sql": ["SELECT * FROM cards GROUP BY artist;"], "sol_sql": [], "preprocess_sql": ["DELETE FROM cards WHERE artist NOT IN ('Ralph Horsley', 'Daarken') LIMIT 1000;", "DELETE FROM cards WHERE artist IS NULL LIMIT 1000;", "CREATE TABLE cards_new AS SELECT id, artist, bordercolor FROM cards;", "DROP TABLE cards;", "ALTER TABLE cards_new RENAME TO cards;"], "clean_up_sql": [], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 13, "selected_database": "debit_card_specializing", "query": "I'm trying to create an SQL query that checks if a SELECT query on the 'transactions_1k' table returns no rows based on a specific criteria involving 'CustomerID' and 'Date'. If no rows are returned, it should then execute another SELECT query with a different criteria. Here's what I mean:\n\nsql\nIF SELECT * FROM transactions_1k WHERE CustomerID = 3 AND Date = '2012-08-24' RETURNS NO ROWS\nTHEN SELECT * FROM transactions_1k WHERE CustomerID = 7626 AND Date = '2012-08-24'\n\n\nIs this possible? I'm not sure if an empty result set counts as 'null', which is causing me some trouble.", "error_sql": ["IF SELECT * FROM transactions_1k WHERE CustomerID = 3 AND Date = '2012-08-24' RETURNS NO ROWS\nTHEN SELECT * FROM transactions_1k WHERE CustomerID = 7626 AND Date = '2012-08-24'"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 14, "selected_database": "financial", "query": "I need to compare the 'account' table with another table, but there are some columns in the 'account' table that I don't need to compare. Specifically, I want to exclude the 'account_id' and 'date' columns from the comparison. I tried to dynamically generate a SQL query to select all columns except these two, but the output SQL was incorrect. Here's the problematic SQL I used:", "error_sql": ["SELECT 'SELECT ' || array_to_string(ARRAY(SELECT 'o' || '.' || c.column_name\n    FROM information_schema.columns As c\n        WHERE table_name = 'account' \n        AND  c.column_name NOT IN('account_id', 'date')\n), ',') || ' FROM accountAs o' As sqlstmt"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 15, "selected_database": "financial", "query": "I have two tables: `account` and `loan`. I need to display the first 6 accounts from a specific district that has loans in the last 48 hours then the rest of the accounts. This works great but I get duplicates from the second query where I repeat these accounts again. I want to make sure `account.account_id` is unique.", "error_sql": ["(\n  SELECT\n    account.account_id,\n    account.frequency,\n    l.loan_id,\n    l.date AS loan_date,\n    0 AS priority\n  FROM account\n  LEFT JOIN loan l\n    ON account.account_id = l.account_id\n  WHERE account.district_id = '18'\n    AND l.date >= (NOW() - INTERVAL '48 hours')\n  ORDER BY l.date DESC NULLS LAST\n  LIMIT 6\n)\nUNION\n(\n  SELECT\n    account.account_id,\n    account.frequency,\n    l.loan_id,\n    l.date AS loan_date,\n    1 AS priority\n  FROM account\n  LEFT JOIN loan l\n    ON account.account_id = l.account_id\n  WHERE account.district_id = '18'\n  ORDER BY account.date DESC\n);"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 16, "selected_database": "student_club", "query": "In the student_club database, there is a table named 'attendance' that records the attendance of members to various events. Each record in this table contains a 'link_to_event' which is a unique identifier for the event, and a 'link_to_member' which is a unique identifier for the member. The goal is to generate a  output that aggregates the attendance records by event, where each event's attendance is represented as an array of member objects. Each member object should contain the member's unique identifier ('link_to_member') and the event's unique identifier ('link_to_event'). The desired  output should be an array of these event-based arrays. However, the user encountered an issue where the output was interpreted as text, introducing undesired escape characters, and the outer array was missing. The user's query was adapted from a suggestion on another post, but it did not produce the desired result.", "error_sql": ["SELECT Array_agg(rw) FROM (SELECT link_to_event, (SELECT To_(Array_agg(Row_to_(t))) FROM (SELECT link_to_member FROM public.attendance WHERE link_to_event = b.link_to_event) t) rw FROM attendance b GROUP BY link_to_event);"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 17, "selected_database": "financial", "query": "In the financial database, we need to generate a list of all years between two given dates from the 'loan' table. The dates are extracted from the 'date' column, which represents the approval date of loans. The goal is to generate all years between the earliest and latest loan approval dates, regardless of the interval between them. For instance, if the earliest loan was approved on '1994-01-05' and the latest on '1997-12-08', we should get a list of years including '1994', '1995', '1996', and '1997'. However, the initial query only returns the starting year if the interval between the dates is less than a year, which is not the desired outcome.", "error_sql": ["SELECT to_char(generate_series, 'YYYY') FROM generate_series(MIN(date)::timestamptz, MAX(date)::timestamptz, '1 year') FROM loan;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 18, "selected_database": "financial", "query": "In the financial database, there is a table named 'loan' that records details of loans given to clients. Each loan is associated with an account, and the table contains columns such as 'loan_id', 'account_id', 'date', 'amount', 'duration', 'payments', and 'status'. The 'amount' column represents the loan amount in USD. The task is to retrieve all rows from the 'loan' table, along with an additional column that shows the maximum loan amount per account. This will help in understanding the highest loan amount each account has taken. However, the user attempted to use the ROW_NUMBER() window function to achieve this, which resulted in incorrect results.", "error_sql": ["SELECT account_id, amount FROM (SELECT account_id, amount, ROW_NUMBER() OVER(PARTITION BY account_id ORDER BY amount DESC) AS rn FROM loan) AS a WHERE rn = 1;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 19, "selected_database": "financial", "query": "In the financial database, we need to create a table to store detailed information about clients, including their first name, last name, and a full name that is automatically generated from the first and last names. The full name should be stored as a generated column. However, when attempting to create the table with a generated column using the CONCAT function, an error occurs indicating that the generation expression is not immutable.", "error_sql": ["CREATE TABLE client_information ( client_id smallserial NOT NULL, first_name character varying(50), last_name character varying(50), full_name character varying(100) GENERATED ALWAYS AS (concat(first_name, ' ', last_name)) STORED, PRIMARY KEY (client_id) );"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": ["DROP TABLE IF EXISTS client_information;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 20, "selected_database": "card_games", "query": "In the context of the card_games database, I frequently need to get a card's row based on its unique UUID, and if it does not exist, I want to create it and return its ID. For example, my table might be the 'cards' table. Suppose I want to insert a card with a specific UUID and name, and if the UUID already exists, I want to return the existing card's ID without modifying the row. However, using the following SQL statement, I encounter issues as it does not return the ID when the row already exists:\\nsql \\\\nINSERT INTO cards(uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') \\\\nON CONFLICT DO NOTHING RETURNING id; \\\\n\\nThis statement does not return the ID of the existing row. I need a solution that returns the ID whether the row is inserted or already exists.", "error_sql": ["INSERT INTO cards(uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT DO NOTHING RETURNING id;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 21, "selected_database": "financial", "query": "In the financial database, I have a table `account` where I need to insert new records or update existing ones based on the `account_id`. The `date` column should be updated to the current date if the record already exists. I want to know whether an `INSERT` or an `UPDATE` operation was performed. I attempted to use an `ON CONFLICT..DO UPDATE` clause but encountered issues with determining the type of operation. I considered adding an `is_update` column to track this, but it feels unnecessary as it is not related to the data itself.", "error_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": ["UPDATE account SET date = '1995-03-24'", "DELETE FROM account WHERE account_id = 22222"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 22, "selected_database": "card_games", "query": "I am analyzing the release dates of Magic: The Gathering card sets to identify periods of consecutive releases. The data includes multiple entries for the same release date due to different printings or variations. I want to find the longest consecutive release periods along with their start and end dates. Here is the structure of the relevant table:\\n- id SERIAL, releaseDate DATE, setCode VARCHAR(50)\\nThe data could have equal release date entries:\\n- id 1, releaseDate 2019-12-28, setCode '10E'\\n- id 2, releaseDate 2019-12-28, setCode '10E'\\n- id 3, releaseDate 2019-12-29, setCode '10E'\\n- id 4, releaseDate 2019-12-29, setCode '10E'\\n- id 5, releaseDate 2019-12-31, setCode '10E'\\n- id 6, releaseDate 2019-12-31, setCode '10E'\\n- id 7, releaseDate 2020-01-01, setCode '10E'\\n- id 8, releaseDate 2020-01-01, setCode '10E'\\n- id 9, releaseDate 2020-01-02, setCode '10E'\\n- id 10, releaseDate 2020-01-03, setCode '10E'\\n- id 11, releaseDate 2020-01-04, setCode '10E'\\n- id 12, releaseDate 2020-01-04, setCode '10E'\\n- id 13, releaseDate 2020-01-05, setCode '10E'\\n- id 14, releaseDate 2020-01-22, setCode '10E'\\n- id 15, releaseDate 2020-01-29, setCode '10E'\\n- id 16, releaseDate 2020-01-30, setCode '10E'\\nI am interested in getting the consecutive release periods with the start and end dates. An output like this:\\n- count | date MIN | date MAX \\\\(6, 2019-12-31, 2020-01-05)\\\\(2, 2019-12-28, 2019-12-29)\\\\(2, 2020-01-29, 2020-01-30)\\nI tried the following SQL query, but it gives incorrect counts and mismatched start/end dates:\\", "error_sql": ["SELECT COUNT(*) -1 AS count, MAX(releaseDate), MIN(releaseDate) FROM (SELECT *, date(releaseDate) - row_number() OVER (PARTITION BY releaseDate ORDER BY date(releaseDate)) * INTERVAL '1 day' AS filter FROM sets_releaseInfo ) t1 GROUP BY filter HAVING COUNT(*) -1 > 0 ORDER BY count DESC"], "sol_sql": [], "preprocess_sql": ["CREATE TEMP TABLE sets_releaseInfo (id SERIAL, releaseDate DATE, setCode VARCHAR(50));", "INSERT INTO sets_releaseInfo (releaseDate, setCode) VALUES ('2019-12-28', '10E'), ('2019-12-28', '10E'), ('2019-12-29', '10E'), ('2019-12-29', '10E'), ('2019-12-31', '10E'), ('2019-12-31', '10E'), ('2020-01-01', '10E'), ('2020-01-01', '10E'), ('2020-01-02', '10E'), ('2020-01-03', '10E'), ('2020-01-04', '10E'), ('2020-01-04', '10E'), ('2020-01-05', '10E'), ('2020-01-22', '10E'), ('2020-01-29', '10E'), ('2020-01-30', '10E');"], "clean_up_sql": ["DROP TABLE IF EXISTS sets_releaseInfo;"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 23, "selected_database": "card_games", "query": "In the card_games database, we have a table named 'collection' where each card can have a reference to another card through the 'nextCardId' column. This column represents the ID of the next card in a sequence. We want to generate a sequence path for each card starting from the card that has no previous card (i.e., no card points to it) and ending at the card that has no next card (i.e., its 'nextCardId' is NULL). The path should be represented as a string of card IDs separated by ' --> '.\\nFor example, if we have the following data:\\n| id  | nextCardId |\\n|-----|------------|\\n| 1   | 5          |\\n| 2   | NULL       |\\n| 3   | 6          |\\n| 4   | 7          |\\n| 5   | 8          |\\n| 6   | 9          |\\n| 7   | NULL       |\\n| 8   | NULL       |\\n| 9   | 10         |\\n| 10  | NULL       |\\nWe want to get the following paths:\\n1 --> 5 --> 8;\\n2;\\n3 --> 6 --> 9 --> 10;\\n4 --> 7;\\nHowever, when we run the following SQL query, we get incorrect results that include incomplete paths:\\nsql;\\nWITH RECURSIVE path_cte AS (\\n  SELECT id, nextCardId, id::TEXT AS Path;\\n  FROM collection\\n  WHERE nextCardId IS NULL\\n  UNION ALL\\n  SELECT collection.id, collection.nextCardId, collection.id || ' --> ' || cte.Path\\n  FROM collection\\n  JOIN path_cte cte ON collection.nextCardId = cte.id\\n)\\nSELECT Path\\nFROM path_cte\\nORDER BY id;\\n\\nWe need to correct this query to get only the complete paths starting from the cards that have no previous card and ending at the cards that have no next card.", "error_sql": ["WITH RECURSIVE path_cte AS (SELECT id, nextCardId, id::TEXT AS Path FROM collection WHERE nextCardId IS NULL UNION ALL SELECT collection.id, collection.nextCardId, collection.id || ' --> ' || cte.Path FROM collection JOIN path_cte cte ON collection.nextCardId = cte.id) SELECT Path FROM path_cte ORDER BY id;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE collection (id INTEGER NOT NULL PRIMARY KEY, nextCardId INTEGER)", "INSERT INTO collection (id, nextCardId) VALUES (1, 5), (2, NULL), (3, 6), (4, 7), (5, 8), (6, 9), (7, NULL), (8, NULL), (9, 10), (10, NULL);"], "clean_up_sql": ["DROP TABLE IF EXISTS collection"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 24, "selected_database": "financial", "query": "In the financial database, I need to classify transactions by quarter, but I want the quarters to start at a configurable month. If I set the quarter to start in April, then April, May, and June should be the first quarter. I think I need a function what_quarter_is(date_in, start_month). For example, what_quarter_is('1995-07-23', 4) = 2. The default EXTRACT(QUARTER FROM date) function in PostgreSQL starts quarters in January, which does not meet my requirements.", "error_sql": ["SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": ["DROP FUNCTION what_quarter_is(date, integer);"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 25, "selected_database": "codebase_community", "query": "In the codebase_community database, I have a table named 'users' with a primary key of 'id'. I need to find all tables, columns, and constraints that reference the 'users' table regardless of which column in 'users' is referenced. For example, if there is a table named 'posts' with a foreign key constraint as follows:\\nCREATE TABLE posts (\\n    id bigint NOT NULL,\\n    owneruserid bigint NULL,\\n    lasteditoruserid bigint NULL,\\n    PRIMARY KEY (id),\\n    FOREIGN KEY (owneruserid) REFERENCES users(id),\\n    FOREIGN KEY (lasteditoruserid) REFERENCES users(id)\\n);\\nI should get back rows like the following:\\nbase_table     base_col    referencing_table   referencing_col  constraint_sql\\nusers          id          posts               owneruserid        CONSTRAINT posts_owneruserid_fkey FOREIGN KEY (owneruserid) REFERENCES users(id)\\nusers          id          posts               lasteditoruserid   CONSTRAINT posts_lasteditoruserid_fkey FOREIGN KEY (lasteditoruserid) REFERENCES users(id)\\nNon-primary key references should also be listed and it should handle compound keys.", "error_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table,\\n       a.attname as base_col,\\n       (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table,\\n       UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col,\\n       pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey)\\n WHERE c.confrelid = (select oid from pg_class where relname = 'users')\\n   AND c.confrelid!=c.conrelid;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 26, "selected_database": "financial", "query": "We have a table 'trans' that records all transactions made by clients in various accounts. Each transaction has a 'trans_id', 'account_id', 'date', 'type', 'operation', 'amount', 'balance', 'k_symbol', 'bank', and 'account'. We need to add a new column 'next_bank' to the 'trans' table that indicates the next non-null 'bank' value for each transaction, ordered by 'date' within each 'account_id'. For example, if a transaction has a null 'bank', the 'next_bank' should be the 'bank' of the next transaction in the same account that has a non-null 'bank'. The user attempted to use the following SQL query, which fails in PostgreSQL due to the lack of support for the 'ignore nulls' clause in the window function. The query is as follows:", "error_sql": ["SELECT first_value(bank ignore nulls) over (partition by account_id order by date rows unbounded following) as next_bank FROM trans;"], "sol_sql": [], "preprocess_sql": ["ALTER TABLE trans ADD COLUMN next_amount int;"], "clean_up_sql": ["ALTER TABLE trans DROP COLUMN next_amount;"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 27, "selected_database": "european_football_2", "query": "I have two separate queries that I want to combine. The first query retrieves the team_api_id and short names of teams from the Team table. The second query retrieves the buildUpPlaySpeed from the Team_Attributes table, based on the team_api_id. I want to combine these two queries into a single query that outputs theteam_api_id, team long name, and the corresponding buildUpPlaySpeed. I have tried the following sql: \\nsql \\\\\\\\nSELECT team_api_id, team_short_name FROM Team as data FULL OUTER JOIN ( SELECT buildUpPlaySpeed, team_api_id FROM Team_Attributes ta WHERE team_api_id = data.team_api_id ) AS subquery_alias ON data.team_api_id = subquery_alias.team_api_id; \\\\\\\\n\\n However, when I ran this query, I encountered an error: There is an entry for table 'data' but it cannot be referenced from this part of the query. How can I modify my query so that it properly combines the results of the two queries?", "error_sql": ["SELECT team_api_id, team_short_name FROM Team as data FULL OUTER JOIN (SELECT buildUpPlaySpeed, team_api_id FROM Team_Attributes ta WHERE team_api_id = data.team_api_id) AS subquery_alias ON data.team_api_id = subquery_alias.team_api_id;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 28, "selected_database": "financial", "query": "We have two tables in our financial database: `trans` and `loan`. The `trans` table records all transactions made by clients, while the `loan` table records all loans issued to clients. Each transaction and loan has a timestamp indicating when it occurred. We want to combine these two tables into a single dataset, without worrying about clashing IDs, and then count the number of actions (transactions and loans) per year. The goal is to produce a result set that shows the total number of actions in each year (order by year). I attempted to write a query but encountered an error related to the GROUP BY clause.", "error_sql": ["WITH one AS ( SELECT date_trunc('year', date) as timeOne, COUNT(*) as trans_count FROM trans ORDER BY timeOne ), two AS ( SELECT date_trunc('year', date) as timeTwo, COUNT(*) as loan_count FROM loan ORDER BY timeTwo ) SELECT timeOne as year, SUM(trans_count, loan_count) as count FROM one, two ORDER BY 1;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 29, "selected_database": "debit_card_specializing", "query": "In the context of the debit_card_specializing database, we need to draw the first place to fifth place winners from a pool of customers based on their transaction amounts. A customer can't win multiple places. If a customer hasn't placed, then all of their transaction amounts must be considered in the draw. The goal is to draw all five place winners efficiently without repeating the query multiple times. The transactions_1k table contains the necessary data with columns such as CustomerID and Amount. The user initially attempted to draw one winner but couldn't extend the logic to draw all five winners without eliminating previous winners in each subsequent draw.", "error_sql": ["WITH gen_transactions AS (SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER))), shuffle AS (SELECT CustomerID, Amount, row_number() OVER (ORDER BY random()) AS rn FROM gen_transactions) SELECT * FROM shuffle ORDER BY RANDOM() LIMIT 1;"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 30, "selected_database": "card_games", "query": "The data in the table \"card_infomation\" includes one column named \"price\". I am using postgres and I have multiple entries of jsonb inside an array in a single column called price. They're input as the card names and corresponding prices. There are multiple rows, with multiple json elements inside of each one of them. I would like to combine them into one big entry in one row, so that I will just have one row of one column as a result.", "error_sql": ["\nINSERT INTO card_information(price) SELECT jsonb_agg(price) FROM (SELECT price FROM card_information) AS subquery; SELECT * FROM card_information;\n"], "sol_sql": [], "preprocess_sql": ["\nCREATE TABLE card_information (price JSONB); \nINSERT INTO card_information (price) VALUES \n('[{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5}]'::jsonb), \n('[{\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5}]'::jsonb), \n('[{\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}]'::jsonb);\nSELECT * FROM card_information;\n"], "clean_up_sql": ["DROP TABLE card_information;"], "test_cases": [], "external_data": "{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5},{\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5},{\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}", "issue_type": "Management"}
{"instance_id": 31, "selected_database": "financial", "query": "In the financial database, I have two tables: `trans` and `account`. The `trans` table contains transaction details including the `account_id`, `date`, `type`, `operation`, `amount`, `balance`, `k_symbol`, `bank`, and `account`. The `account` table contains account details including `account_id`, `district_id`, `frequency`, and `date`. For each transaction in the `trans` table that matches a specific `account_id` and `type`, I want to join the corresponding record in the `account` table with the minimum transaction date. I want to group the results by `k_symbol` and extract the `k_symbol`, `operation`, `amount`,  `balance`, and `frequency` from the selected transaction record.", "error_sql": ["SELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency FROM trans t INNER JOIN account a ON t.account_id = a.account_id WHERE t.account_id = 1 AND t.type = 'PRIJEM' GROUP BY t.k_symbol -- and t.date is the minimum for each group;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 32, "selected_database": "card_games", "query": "I am trying to analyze the purchasing behavior of users in our card_games database to find out the count of sequential monthly purchases and their lengths for each user. I want to identify the longest streaks of consecutive monthly purchases for each user and then count how many users have each longest streak length. For example, if a user made purchases in March, April, May, and June, that would be a streak of 4 months. If another user made purchases in January, February, and March, that would be a streak of 3 months. I need to find the longest streak for each user and then count how many users have the longest streak of a certain length. The expected result should show the streak length and the number of users who have that longest streak length.", "error_sql": ["\nSELECT user_id, COUNT(*) AS num_consecutive_months FROM (SELECT user_id, purchase_date, DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD')) AS month_date, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD'))) - ROW_NUMBER() OVER(PARTITION BY user_id, DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD')) - INTERVAL '1 month' * ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD')))) AS grp FROM purchase) sub GROUP BY user_id, grp ORDER BY COUNT(*) DESC LIMIT 1;\n"], "sol_sql": [], "preprocess_sql": ["\nCREATE TABLE purchase ( purchase_date VARCHAR(255), user_id VARCHAR(255) ); INSERT INTO purchase(purchase_date, user_id) VALUES('2020-03', 'alex01'), ('2020-04', 'alex01'), ('2020-05', 'alex01'), ('2020-06', 'alex01'), ('2020-12', 'alex01'), ('2021-01', 'alex01'), ('2021-02', 'alex01'), ('2021-03', 'alex01'), ('2020-04', 'jon03'), ('2020-05', 'jon03'), ('2020-06', 'jon03'), ('2020-09', 'jon03'), ('2021-11', 'jon03'), ('2021-12', 'jon03'), ('2022-01', 'jon03'), ('2022-02', 'jon03'), ('2020-05', 'mark05'), ('2020-06', 'mark05'), ('2020-07', 'mark05'), ('2020-08', 'mark05'), ('2020-09', 'mark05');\n"], "clean_up_sql": ["DROP TABLE purchase;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 33, "selected_database": "financial", "query": "I am working with a table containing card IDs, company names, and types. My task is to extract the pure card id without company information, \"pure_cardid\", from the cardid field by removing the substring between the first and second hyphens. Afterward, I need to retrieve the minimum value of type for each unique \"pure_cardid\", considering that multiple records may exist for the same \\pure_cardid\". My main challenge is how to correctly perform both the string manipulation and the aggregation in a single query.", "error_sql": ["\nWITH tab_with_cardid AS (\n   select split(cardid, '-', 3)ivm_arr,\n\n           type,\n           last_refresh_date\n    FROM db.scema.table\n), ranked_visits AS (\n    SELECT *, ROW_NUMBER() OVER(PARTITION BY CONCAT(ivm_arr[2],item) as temp ORDER BY type) AS rn\n    FROM tab_with_cardid\n)\nSELECT cardid, pure_cardid\nFROM ranked_visits\nWHERE rn = 1\n"], "sol_sql": [], "preprocess_sql": ["\nCREATE TABLE card_info (\n    cardid VARCHAR(50),\n    company VARCHAR(10),\n    type CHAR(1)\n);\n\nINSERT INTO card_info (cardid, company, type) VALUES\n('1234-5678-HIJK', '1234', 'A'),\n('1234-9012-HIJK', '1234', 'B'),\n('56457-12456-DF-GH-TC', '56457', 'D');\n"], "clean_up_sql": ["DROP TABLE card_info;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 34, "selected_database": "european_football_2", "query": "Suppose we have the following table in the 'european_football_2' database that records the overall rating of players over time:\\n|player_api_id|date|overall_rating|\\n|-------------|----|--------------|\\n|505942       |2016-02-18|67          |\\n|505942       |2015-11-19|67          |\\n|505942       |2015-09-21|62          |\\n|155782       |2016-03-15|75          |\\n|155782       |2015-12-10|74          |\\n|162549       |2016-01-20|70          |\\n|162549       |2015-10-25|68          |\\nFor each player, we want the latest overall rating based on the date. The final table would be:\\n|player_api_id|date|overall_rating|\\n|-------------|----|--------------|\\n|505942       |2016-02-18|67          |\\n|155782       |2016-03-15|75          |\\n|162549       |2016-01-20|70          |\\nI attempted to group by player_api_id while ordering by date and then getting the first value:\\nsql \\\\nSELECT player_api_id, MAX(date), FIRST(overall_rating) \\\\nFROM Player_Attributes \\\\nGROUP BY player_api_id \\\\nORDER BY date desc \\\\n\\nBut this doesn't work.", "error_sql": ["SELECT player_api_id, MAX(date), FIRST(overall_rating) FROM Player_Attributes GROUP BY player_api_id ORDER BY date desc;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 35, "selected_database": "codebase_community", "query": "I am using a tool that allows querying user data in our local database using the PostgreSQL interface. I am running a simple query to print all ages of the users on our platform. However, I am getting an error message that says 'ERROR:  invalid input syntax for type numeric: \"text\"'. I am not sure why I am getting this error. Can you help me understand why this error is occurring and how I can fix it?", "error_sql": ["SELECT Age::numeric FROM users;"], "sol_sql": [], "preprocess_sql": ["ALTER TABLE users ALTER COLUMN Age SET DATA TYPE text; INSERT INTO users VALUES (1212121,3150,'2010-07-19 19:09:39','JMS','2014-09-13 04:03:25',NULL,NULL,NULL,257,138,7,134002,'Invalid Age',NULL);"], "clean_up_sql": ["DELETE FROM users WHERE id = 1212121; ALTER TABLE users ALTER COLUMN age SET DATA TYPE integer USING age::integer;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 36, "selected_database": "codebase_community", "query": "In our local database, we have two tables `users` and `profiles`. When a new user is added to the `users` table, we want to automatically create a corresponding profile in the `profiles` table. The `profiles` table has three columns: `id`, `CreationDate`, and `WebsiteUrl`. The `WebsiteUrl` should be derived from the user's WebsiteUrl by taking the part before the '.com'  and after the 'http://'. For example, 'http://stackoverflow.com' should become 'stackoverflow'. To achieve this, I created a trigger on the `users` table with the following function: sql begin insert into profiles (Id, CreationDate, WebsiteUrl) select new.id, new.WebsiteUrl, left(replace(new.WebsiteUrl, '.', '-'), charindex('@', replace(new.WebsiteUrl, '.', '-')) - 1); return new; end;  However, when a new user is added, I encounter the error:  ERROR: function charindex(unknown, text) does not exist (SQLSTATE 42883)", "error_sql": ["begin insert into profiles (Id, CreationDate, WebsiteUrl) select new.Id, new.CreationDate, left(replace(new.WebsiteUrl, '.', '-'), charindex('@', replace(new.WebsiteUrl, '.', '-')) - 1); return new; end;"], "sol_sql": [], "preprocess_sql": ["DROP TABLE IF EXISTS profiles; CREATE TABLE profiles (id varchar(256) NOT NULL, CreationDate text, WebsiteUrl text, PRIMARY KEY (id));"], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 37, "selected_database": "financial", "query": "We have a large transaction table in our financial database with over 180 million rows and 20 GB in size. The table is structured to store detailed transaction records for various accounts. We are running a query to retrieve specific transactions based on a list of account IDs, a specific bank, and a range of transaction types. The query is taking an unexpectedly long time to execute when the shared buffers are cold, around 9 seconds, but only 25 ms when the data is cached. We suspect that the query planner is not choosing the most optimal execution plan. We have tried adding a covering index and forcing a Bitmap Heap Scan, but we would like to understand why the planner is not making the best choice and find a more permanent solution to improve performance to around 1-2 seconds.", "error_sql": ["SELECT t.trans_id,       t.account_id,       t.date,       t.type,       t.amount  FROM trans t  JOIN account a    ON t.account_id = a.account_id WHERE a.district_id = 18   AND t.bank = 'AB'  AND t.type IN ('PRIJEM', 'VYDAJ')"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 38, "selected_database": "card_games", "query": "A user is working with a table named `cards` in the `card_games` database. They want to find card records that match specific criteria: `availability` is 'paper', `bordercolor` is 'black', `rarity` is 'uncommon', and `type` is 'Creature'. They can write a query to get rows that match all these conditions. However, they also want to find cards that meet 3 out of these 4 criteria. Can this be done in a single SQL query?", "error_sql": ["SELECT * FROM cards WHERE availability = 'paper' AND bordercolor = 'black' AND rarity = 'uncommon' AND types = 'Creature';"], "sol_sql": [], "preprocess_sql": [], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 39, "selected_database": "student_club", "query": "I want to insert a new event into the 'event' table and, in case of a duplicate event ID (which is unique), log the failure in the 'failure' table with specific event ID and member ID indicating the error. For example, I want to insert an event with the ID 'recAlAwtBZ0Fqbr5K' and name 'Annual Gala'. If it fails due to a duplicate name, log the failure with the member ID 'rec280Sk7o31iG0Tx'. My current SQL statement is producing an error: syntax error at or near 'insert'.", "error_sql": ["insert into event (event_id, event_name, event_date, type, notes, location, status) values ('recAlAwtBZ0Fqbr5K', 'Annual Gala', '2023-12-15T19:00:00', 'Social', 'Annual Gala for club members', 'Grand Ballroom', 'Open') on conflict (event_id) do insert into failure (event, member) values ('recAlAwtBZ0Fqbr5K', 'rec280Sk7o31iG0Tx');"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE failure (event VARCHAR(255) NOT NULL, member VARCHAR(255) NOT NULL, PRIMARY KEY (event, member));"], "clean_up_sql": ["DROP TABLE IF EXISTS failure;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 40, "selected_database": "european_football_2", "query": "I am new to functions and triggers in PostgreSQL. I am trying to create a trigger function to log changes in the player's name in the Player table. I followed a tutorial but encountered an error. The code block and the error are provided below. The Player table contains detailed information about players. The player_audits table is intended to keep track of any changes to the player's name along with the timestamp of the change.", "error_sql": ["CREATE OR REPLACE FUNCTION log_player_name_changes() RETURNS trigger AS $BODY$ BEGIN IF NEW.player_name <> OLD.player_name THEN INSERT INTO player_audits(player_id, old_player_name, changed_on) VALUES(OLD.id, OLD.player_name, now()); END IF; RETURN NEW; END; $BODY$ CREATE TRIGGER tr_change_playername AFTER UPDATE OF player_name ON player FOR EACH ROW EXECUTE PROCEDURE log_player_name_changes();"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE player_audits (player_id int, old_player_name text, changed_on timestamp );"], "clean_up_sql": ["DROP TABLE IF EXISTS player_audits;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 41, "selected_database": "student_club", "query": "\nI have an event_attendance table and what I am trying to build should be one row for each member.\\nColumn definitions of the expected output:\\nGame_AttendanceDate : Latest attendance date based on date where EventType = 'Game'\\nGame_Attendances: Total number of Game events attended by each member.\\nWorkshop_AttendanceDate: Latest attendance date based on date where EventType = 'Workshop'\\nWorkshop_Attendances: Total number of Workshop events attended by each member.\\nTotal_Attendances: Total events attended by each member. I tried on one categories but I have to do this calculation for another 2 categories then that will add up another 2 sub queries. Is there anyway to optimize the SQL code?\n", "error_sql": ["\nSELECT\n    COALESCE(a.MemberID, b.MemberID) AS MemberID,\n    a.AttendanceDate AS Latest_Game_Date,\n    a.Game_Attendance AS Total_Game_Attendance,\n    b.AttendanceDate AS Latest_Workshop_Date,\n    b.Workshop_Attendance AS Total_Workshop_Attendance,\n    a.Game_Attendance + b.Workshop_Attendance AS Total_Attendance\nFROM \n(\n    SELECT \n        MemberID, \n        EventType,\n        AttendanceDate,\n        COUNT(EventID) OVER(PARTITION BY MemberID, EventType) AS Game_Attendance,\n        ROW_NUMBER() OVER(PARTITION BY MemberID, EventType ORDER BY AttendanceDate DESC) AS RNUM\n    FROM event_attendance\n    WHERE EventType = 'Game'\n) a\nFULL JOIN \n(\n    SELECT \n        MemberID, \n        EventType,\n        AttendanceDate,\n        COUNT(EventID) OVER(PARTITION BY MemberID, EventType) AS Workshop_Attendance,\n        ROW_NUMBER() OVER(PARTITION BY MemberID, EventType ORDER BY AttendanceDate DESC) AS RNUM\n    FROM event_attendance\n    WHERE EventType = 'Workshop'\n) b\nON a.MemberID = b.MemberID\nWHERE (a.RNUM = 1 OR a.RNUM IS NULL) AND (b.RNUM = 1 OR b.RNUM IS NULL);\n"], "sol_sql": [], "preprocess_sql": ["\nCREATE TABLE event_attendance (MemberID int, EventID int, EventType text, AttendanceDate date); INSERT INTO event_attendance (MemberID, EventID, EventType, AttendanceDate) VALUES (1, 101, 'Game', '2023-01-01'), (1, 102, 'Game', '2023-01-10'), (1, 103, 'Game', '2023-02-15'), (1, 104, 'Game', '2023-02-20'), (1, 105, 'Workshop', '2023-03-01'), (1, 106, 'Workshop', '2023-03-20'), (2, 107, 'Game', '2023-01-15'), (2, 108, 'Workshop', '2023-02-06');\n"], "clean_up_sql": ["DROP TABLE event_attendance;"], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 42, "selected_database": "codebase_community", "query": "\nI'm working with a table called `preference_tag`, which contains a `userid` and an array of tags in the `tag` column. \nI need to find rows in the user's tag preference table where the array contains the corresponding tags. \nFor example, when querying with `ARRAY['friend', 'cat']`, it works as expected, returning the rows where the array contains both 'friend' and 'cat'. \nHowever, when I try to use wildcard symbols (e.g., `ARRAY['%friend%', '%cat%']`), it doesn't return the expected results. \nThe issue seems to be related to the `%` symbols, as I want to match any values that contain substrings like 'friend' or 'cat', but I don't need an exact match.\n", "error_sql": ["\nSELECT DISTINCT userid, tag\nFROM preference_tag\nWHERE tag @> (ARRAY['friend', 'cat']::VARCHAR[]);\n"], "sol_sql": [], "preprocess_sql": ["\nCREATE TABLE preference_tag (\n    userid INT PRIMARY KEY,\n    tag TEXT[]\n);\n\nINSERT INTO preference_tag (userid, tag) VALUES\n(1, ARRAY['friend', 'apple', 'cat']),\n(2, ARRAY['cat', 'friend', 'dog']),\n(3, ARRAY['pasta', 'best-friend', 'lizard']),\n(4, ARRAY['wildcat', 'potato', 'alices-friend']);\n\n"], "clean_up_sql": ["DROP TABLE preference_tag;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 43, "selected_database": "financial", "query": "In the financial database, there is a table named 'account_info' that stores the detailed information of accounts. Each row in the table includes an array in the 'condition' column, which contains various conditions related to the account. We need to find all qualifying accounts where the 'condition' column contains a condition with a specific 'rootcompanyid' value of 5. The current query is only returning the last row that matches the condition, but we need all rows that have this 'rootcompanyid' value in any part of the array.", "error_sql": ["SELECT *  FROM account_info WHERE ((condition->0->>'conditions')::json->>'rootcompanyid')::json->>'$in' = '[5]';"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS account_info (account_id INTEGER, condition JSONB);", "INSERT INTO account_info (account_id, condition) VALUES (1, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[35,20,5,6]}}}]'::jsonb), (2, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[1,4,2,3,6]}}}]'::jsonb), (3, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[5]}}}]'::jsonb);"], "clean_up_sql": ["DROP TABLE IF EXISTS account_info;"], "test_cases": [], "external_data": "{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[35,20,5,6]}}}, {\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[1,4,2,3,6]}}}, {\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[5]}}}", "issue_type": "Personalization"}
{"instance_id": 44, "selected_database": "superhero", "query": "I am working on a superhero database and have a table called 'hero_power' that records the powers of each superhero. Currently, the combination of 'hero_id' and 'power_id' is supposed to be unique, meaning that a superhero cannot have the same power listed more than once. However, this is not quite what I want. Instead, I would want the combination 'hero_id' and 'power_id' to be unique only in cases where the power is currently active. In other words, a superhero should be able to have multiple instances of the same power listed if the power is inactive, but should not be allowed to have duplicates that are active. Is there a way to enforce this in this table?", "error_sql": ["ALTER TABLE hero_power ADD CONSTRAINT unique_active_hero_power UNIQUE (hero_id, power_id);"], "sol_sql": [], "preprocess_sql": ["ALTER TABLE hero_power ADD COLUMN active BOOLEAN DEFAULT TRUE;"], "clean_up_sql": ["ALTER TABLE hero_power DROP COLUMN IF EXISTS active;", "DROP INDEX IF EXISTS idx_hero_power_active;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 45, "selected_database": "toxicology", "query": "In the toxicology database, we have a table named `orders` that records the purchases made by users. Each record includes the `user_id`, `email`, `segment`, `destination`, and `revenue`. We need to identify users who meet specific criteria based on their purchase history:\\n1) Users who have made a purchase in the `luxury` segment with a `destination` of `New York`.\\n2) Users who have made a purchase in the `luxury` segment with a `destination` of `London`.\\n3) Users who have made purchases in the `basic` segment with a `destination` of `New York` and the total revenue from these purchases exceeds $2,000.\\n4) Users who have never made a purchase with a `destination` of `Miami`.\\nGiven the sample data, we expect to retrieve the following users:\\nuser_id     email \\\\(3           mike@me.com \\\\(4           sally@you.com \\\\(5           bob@gmail.com \\\\)The user attempted to use the following SQL query to get part of the required results, but it did not account for conditions 3 and 4:\\nsql \\\\(SELECT DISTINCT(user_id), email FROM orders o WHERE (o.segment = 'luxury' AND o.destination = 'New York') OR (o.segment = 'luxury' AND o.destination = 'London') \\\\)", "error_sql": ["SELECT DISTINCT(user_id), email FROM orders o WHERE (o.segment = 'luxury' AND o.destination = 'New York') OR (o.segment = 'luxury' AND o.destination = 'London')"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE orders (user_id INT, email TEXT, segment TEXT, destination TEXT, revenue NUMERIC); INSERT INTO orders (user_id, email, segment, destination, revenue) VALUES (1, 'joe@smith.com', 'basic', 'New York', 500), (1, 'joe@smith.com', 'luxury', 'London', 750), (1, 'joe@smith.com', 'luxury', 'London', 500), (1, 'joe@smith.com', 'basic', 'New York', 625), (1, 'joe@smith.com', 'basic', 'Miami', 925), (1, 'joe@smith.com', 'basic', 'Los Angeles', 218), (1, 'joe@smith.com', 'basic', 'Sydney', 200), (2, 'mary@jones.com', 'basic', 'Chicago', 375), (2, 'mary@jones.com', 'luxury', 'New York', 1500), (2, 'mary@jones.com', 'basic', 'Toronto', 2800), (2, 'mary@jones.com', 'basic', 'Miami', 750), (2, 'mary@jones.com', 'basic', 'New York', 500), (2, 'mary@jones.com', 'basic', 'New York', 625), (3, 'mike@me.com', 'luxury', 'New York', 650), (3, 'mike@me.com', 'basic', 'New York', 875), (4, 'sally@you.com', 'luxury', 'Chicago', 1300), (4, 'sally@you.com', 'basic', 'New York', 1200), (4, 'sally@you.com', 'basic', 'New York', 1000), (4, 'sally@you.com', 'luxury', 'Sydney', 725), (5, 'bob@gmail.com', 'basic', 'London', 500), (5, 'bob@gmail.com', 'luxury', 'London', 750);"], "clean_up_sql": ["DROP TABLE orders;"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 46, "selected_database": "formula_1", "query": "In the Formula 1 database, there is a table named 'cars' which contains the information of cars. Each entry includes a 'version' column that records the version of the car used by the driver in the race. The version numbers are in a format similar to '3.0.5-1-test-dev' and need to be sorted correctly to determine the latest version used in a race. However, the current sorting method does not handle multi-digit numbers correctly and fails when the version includes additional string information after the numeric version. The task is to write a query that correctly sorts the versions. If the table is sorted, I can get the latest version by select the first one.", "error_sql": ["SELECT version FROM cars ORDER BY SUBSTRING(version, '^[0-9]+') DESC, SUBSTRING(version, '[0-9]+\\.[0-9]+\\.([0-9]+)-') DESC, CAST(SUBSTRING(version, '[0-9]+\\.[0-9]+\\.[0-9]+-([0-9]+)') AS INTEGER) DESC, SUBSTRING(version, '[0-9]+\\.[0-9]+\\.[0-9]+-[0-9]+\\.([0-9]+)') DESC"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE cars (version varchar(100))", "INSERT INTO cars (version) VALUES ('3.0.5-1-test-dev'), ('3.0.6-1'), ('3.0.7-1-test'), ('3.0.8-1-test-dev-test23'), ('3.0.9-1'), ('3.0.13-2'), ('3.0.4-1-1'), ('3.0.10-1'), ('3.0.11-2'), ('3.0.11-1')"], "clean_up_sql": ["DROP TABLE cars;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 47, "selected_database": "thrombosis_prediction", "query": "In the thrombosis_prediction database, we have a set of normalized tables representing patients, medications, and their prescriptions. Each patient can be prescribed multiple medications, and each medication can be prescribed to multiple patients. For reporting purposes, we need a highly denormalized view that shows each patient's name and a list of all medications they are prescribed. However, when we filter the list to show only patients who are prescribed a specific medication (e.g., Aspirin), we lose the information about other medications those patients are prescribed. We want to filter by a specific medication but still get a list of all medications that a patient is prescribed in one row.", "error_sql": ["SELECT prescriptions.patient_id, array_agg(DISTINCT prescriptions.medication_id ORDER BY prescriptions.medication_id) AS medications FROM prescriptions INNER JOIN prescriptions AS Aspirin_filter ON prescriptions.patient_id = Aspirin_filter.patient_id AND Aspirin_filter.medication_id = 1 GROUP BY prescriptions.patient_id;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE patients ( patient_id SERIAL PRIMARY KEY, patient_name TEXT NOT NULL );", "CREATE TABLE medications ( medication_id SERIAL PRIMARY KEY, medication_name TEXT NOT NULL );", "CREATE TABLE prescriptions ( patient_id INT REFERENCES patients (patient_id), medication_id INT REFERENCES medications (medication_id), PRIMARY KEY (patient_id, medication_id) );", "INSERT INTO patients (patient_name) VALUES ('Alice'), ('Bob'), ('Charlie');", "INSERT INTO medications (medication_name) VALUES ('Aspirin'), ('Ibuprofen'), ('Paracetamol'), ('Warfarin');", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (1, 1), (1, 2), (1, 3);", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (2, 2);", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (3, 2), (3, 1), (3, 3), (3, 4);"], "clean_up_sql": [], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 48, "selected_database": "formula_1", "query": "In the context of Formula 1 racing data, I have two tables: `races` and `results`. The `races` table contains information about each race, including the `raceId` which uniquely identifies each race. The `results` table contains detailed information about the results of each race, including the `raceId` to link back to the `races` table, `driverId` to identify the driver, and `points` which represent the points scored by the driver in that race. I need to calculate the total points scored by each driver across all races, but only for races where the driver has participated. If a driver has not participated in any races, their total points should be `0`. I attempted to write a query to achieve this but encountered issues with grouping and ensuring that drivers who haven't participated in any races are included with a total of `0` points.", "error_sql": ["SELECT r.driverId, ((SELECT COALESCE(SUM(r.points), 0) FROM results r WHERE r.raceId = races.raceId) - (SELECT COALESCE(SUM(r.points), 0) FROM results r WHERE r.raceId = races.raceId)) AS total_points FROM results r GROUP BY r.driverId"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 49, "selected_database": "superhero", "query": "In the context of the superhero database, I need to calculate the total count of superheroes by their alignment and also display the count of superheroes for each specific alignment and race combination. I attempted to write a query to achieve this but it doesn't provide the total count by alignment as I expected. Here's what I tried:", "error_sql": ["select count(S.id), A.alignment, count(R.race), R.race from superhero S, alignment A, race R where S.alignment_id=A.id and S.race_id=R.id group by A.alignment, R.race;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 50, "selected_database": "formula_1", "query": "In the context of analyzing Formula 1 race results, I'm trying to understand the behavior of window functions in PostgreSQL. Specifically, I'm looking at the `array_agg` function with and without an `ORDER BY` clause within a window function. I expect both to return the same result since no filtering is applied, but they don't. Here's the scenario: I have a table of race results, and I want to aggregate the driver IDs in two ways: one with an order by the points they scored in the race, and another without any order. The results seem to suggest that ordering the partition affects the aggregation, which is confusing. Here's the SQL I used:", "error_sql": ["select driverId, points, lead(driverId) over (order by points asc) as \"lead(driverId) with order\", array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", lead(driverId) over () as \"lead(driverId) without order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 51, "selected_database": "formula_1", "query": "In the context of Formula 1 racing data analysis, a user is attempting to calculate the total duration of pit stops for each race day based on the difference between consecutive pit stop times recorded in the same column. The user has a table that records pit stop details including race ID, driver ID, stop number, lap number, pit stop time, and duration. The user's initial approach was to calculate the maximum and minimum pit stop times for each race day and then find the difference between these times to estimate the total pit stop duration. However, this approach misses the intermediate pit stops, leading to an inaccurate total duration calculation. The user is seeking a method to accurately calculate the total pit stop duration by considering all consecutive pit stop times for each race day.", "error_sql": ["SELECT \n  raceId,\n  MAX(time::time) AS end_time,\n  MIN(time::time) AS start_time,\n  (MAX(time::time) - MIN(time::time)) AS total_duration\nFROM pitStops\nWHERE raceId = 842\nGROUP BY raceId;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 52, "selected_database": "toxicology", "query": "In the toxicology database, I'm attempting to retrieve a specific data structure from a query. My data is structured in a way that each molecule has atoms connected by bonds, and each molecule is labeled as either carcinogenic or not carcinogenic. I want to return a  object that groups molecules by their label and lists the atoms and bonds for each molecule. The desired output format is a  object where each key is a label, and the value is an array of objects, each representing a molecule with its atoms and bonds. Here's the SQL query I have so far, but it doesn't produce the desired output structure:", "error_sql": ["select label, JSON_AGG(JSON_BUILD_OBJECT(atom.molecule_id, atom.atom_id)) AS groupedMolecules FROM molecule JOIN atom ON molecule.molecule_id = atom.molecule_id GROUP BY label"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 53, "selected_database": "toxicology", "query": "In the context of a toxicology database, I have a `molecule` table that tracks molecules and their carcinogenic status, and an `atom` table that records atoms within these molecules. Each atom is identified by a unique `atom_id` and belongs to a molecule identified by `molecule_id`. The `element` column in the `atom` table specifies the chemical element of the atom. I need to count the number of sodium and carbon or chlorine atoms for each molecule. However, if both carbon and chlorine elements within the same molecule, they should be counted as one. Here's the SQL query I attempted, but it counts each atom individually, even if they are of the same element within the same molecule:", "error_sql": ["SELECT molecule_id, COALESCE(SUM(CASE WHEN element = 'na' THEN 1 ELSE 0 END), 0) na_atoms, COALESCE(SUM(CASE WHEN element = 'c' OR element = 'cl' THEN 1 ELSE 0 END), 0) c_atoms FROM atom GROUP BY molecule_id;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 54, "selected_database": "european_football_2", "query": "In the context of analyzing football match data, I'm attempting to calculate the average number of goals scored by each team, grouped by the hour of the match. The goal is to understand the performance trends of teams at different times of the day without resorting to external scripting. Here's the initial approach I took, which unfortunately resulted in an error due to incorrect handling of the timestamp data.", "error_sql": ["SELECT home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY home_team_api_id, date_part('hour', date);"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 55, "selected_database": "debit_card_specializing", "query": "In the table clients_to_groups, we need to identify clients who have made transactions at gas stations that belong to specific groups. Specifically, we want to find clients who have made transactions at gas stations that are either in the group 1 or 3 AND also in group 5 or 6. For example, a client who has made transactions at a gas station in the group 5 and another transaction at a gas station in the group 1 should be included in the results, but a client who has only made transactions at gas stations in the group 5 should not be included.", "error_sql": ["SELECT DISTINCT c.id FROM clients c INNER JOIN clients_to_groups at1 ON c.id = at1.client_id INNER JOIN clients_to_groups at2 ON c.id = at2.client_id WHERE at1.group_id IN (5, 6) AND at2.group_id IN (1, 3);"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE clients (id INT NOT NULL);", "CREATE TABLE groups (id INT NOT NULL);", "CREATE TABLE clients_to_groups (id serial, group_id INT, client_id INT);", "INSERT INTO clients(id) VALUES (0), (1), (2), (3);", "INSERT INTO groups(id) VALUES (1), (3), (5), (6);", "INSERT INTO clients_to_groups(client_id, group_id) VALUES (0, 1), (0, 5), (1, 1), (1, 90), (2, 1), (3, 3), (3, 5), (3, 90);", "INSERT INTO clients (id) SELECT random() from generate_series(1,2000);", "INSERT INTO clients_to_groups(client_id, group_id) SELECT random(), random() from generate_series(1,2000);"], "clean_up_sql": ["DROP TABLE clients;", "DROP TABLE groups;", "DROP TABLE clients_to_groups;"], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 56, "selected_database": "european_football_2", "query": "In the context of the 'european_football_2' database, consider a table that records daily financial transactions for football clubs. Each transaction includes the date, the club name, and the amount of money involved, which can be positive or negative. The goal is to group these transactions by club and sign (positive or negative) and sum the amounts for consecutive transactions of the same sign for each club. For example, if a club has consecutive positive transactions, they should be summed up into a single transaction. The user attempted to use window functions but encountered issues with their query, which did not produce the desired output.", "error_sql": ["SELECT transaction_date AS date, club_name, sum(amount) over (partition by club_name, sign(amount) order by transaction_date) from club_transactions"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE club_transactions (transaction_date DATE, club_name VARCHAR(50), amount INTEGER);", "INSERT INTO club_transactions (transaction_date, club_name, amount) VALUES ('2023-01-01', 'Manchester United', 3), ('2023-01-02', 'Manchester United', 2), ('2023-01-03', 'Manchester United', 1), ('2023-01-04', 'Manchester United', -5), ('2023-01-05', 'Manchester United', 1), ('2023-01-01', 'Liverpool', 2), ('2023-01-02', 'Liverpool', -1), ('2023-01-03', 'Liverpool', -6);"], "clean_up_sql": ["DROP TABLE club_transactions;"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 57, "selected_database": "california_schools", "query": "I have a table in Postgres that returns flat data. But I would like it to be returned to me in a Json ordered with its children as follows, and I have not been able to solve it.Is there a way in postgresql to order the parent modules with their child modules, I attach an example \"[{\"children\":[{\"id_module\":4,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":1},{\"id_module\":3,\"desc_module\":\"C\",\"module_code\":\"232\",\"name_module\":\"C\",\"id_parent_module\":1},{\"id_module\":2,\"desc_module\":\"B\",\"module_code\":\"011.002\",\"name_module\":\"B\",\"id_parent_module\":1}],\"id_module\":1,\"desc_module\":\"A\",\"module_code\":\"001\",\"name_module\":\"A\",\"id_parent_module\":null},{\"children\":[{\"id_module\":14,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":5}],\"id_module\":5,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":22,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6},{\"id_module\":8,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6},{\"id_module\":7,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6}],\"id_module\":6,\"desc_module\":\"qw\",\"module_code\":\"23\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":21,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":9},{\"id_module\":20,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":9}],\"id_module\":9,\"desc_module\":\"asdfsad\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":13,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":10},{\"id_module\":12,\"desc_module\":\"asdfsf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":10},{\"id_module\":11,\"desc_module\":\"asdf\",\"module_code\":\"sadf\",\"name_module\":\"asdf\",\"id_parent_module\":10}],\"id_module\":10,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null}]\"", "error_sql": ["SELECT array_to_json(array_agg(row_to_json(alias))) FROM (select * from modules ) alias"], "sol_sql": [], "preprocess_sql": ["create table modules (id_module int, id_parent_module int, module_code text, name_module text, desc_module text);", "insert into modules values (1, null, '001', 'A', 'A'), (2, 1, '011.002', 'B', 'B'), (3, 1, '232', 'C', 'C'), (4, 1, 'asdf', 'asdf', 'asdf'), (5, null, 'asdf', 'asdf', 'asdf'), (14, 5, 'asdf', 'asdf', 'asdf'), (6, null, '23', 'asdf', 'qw'), (7, 6, 'asdf', 'asdf', 'asdf'), (8, 6, 'asdf', 'asdf', 'asdf'), (22, 6, 'asdf', 'asdf', 'asdf'), (9, null, 'asdf', 'asdf', 'asdfsad'), (20, 9, 'asdf', 'asdf', 'asdf'), (21, 9, 'asdf', 'asdf', 'asdf'), (10, null, 'asdf', 'asdf', 'asdf'), (11, 10, 'sadf', 'asdf', 'asdf'), (12, 10, 'asdf', 'asdf', 'asdfsf'), (13, 10, 'asdf', 'asdf', 'asdf');"], "clean_up_sql": ["DROP TABLE modules;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 58, "selected_database": "toxicology", "query": "In the toxicology database, we have a table named 'atom_edits' that records updates to the 'atom' table. Users can update the 'element' or 'molecule_id' of an atom. If a field is not updated, it retains a NULL value. Here's an example of four edits touching two separate atoms. Atom with ID 'TR000_1' received two updates: the first one is updating the 'element' field, the second one touches the 'molecule_id'. Atom with ID 'TR000_2' received one update that changes the 'element'. We need to merge this table such that in the resulting table there's one row per atom, giving the cumulative edits.", "error_sql": ["SELECT atom_id, (ARRAY_REMOVE(ARRAY_AGG(element ORDER BY edit_id DESC), NULL))[1] AS element, (ARRAY_REMOVE(ARRAY_AGG(molecule_id ORDER BY edit_id DESC), NULL))[1] AS molecule_id FROM atom_edits GROUP BY atom_id;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE atom_edits (edit_id SERIAL PRIMARY KEY, atom_id TEXT, element TEXT, molecule_id TEXT); INSERT INTO atom_edits (atom_id, element, molecule_id) VALUES ('TR000_1', 'cl', NULL), ('TR000_1', NULL, 'TR001'), ('TR000_2', 'c', NULL);"], "clean_up_sql": ["DROP TABLE atom_edits;"], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 59, "selected_database": "debit_card_specializing", "query": "We are trying to bulk insert a large number of customer records into the `customers` table using an `INSERT` statement with an `ON CONFLICT` clause. The goal is to get the `CustomerID` back for all rows, whether they are already existing or not. The `customers` table has a composite unique constraint on `Segment` and `Currency`. We are encountering an error when trying to run the SQL through Django's cursor. The error message indicates that the `ON CONFLICT DO UPDATE` command cannot affect a row a second time due to duplicate constrained values in the `VALUES` list. We need to handle this situation to ensure that we can insert new records and retrieve the IDs of both new and existing records.", "error_sql": ["INSERT INTO customers (customerid, segment, currency) VALUES (3, 'SME', 'EUR'), (1, 'KAM', 'CZK'), (3, 'SME', 'EUR') ON CONFLICT (customerid, segment, currency) DO UPDATE SET Currency = customers.Currency RETURNING CustomerID;"], "sol_sql": [], "preprocess_sql": ["ALTER TABLE customers\nADD CONSTRAINT customers_customerid_segment_currency_uk\nUNIQUE (customerid, segment, currency);"], "clean_up_sql": ["DROP TABLE customers;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 60, "selected_database": "financial", "query": "In the financial database, there are two tables: 'client' and 'disp'. The 'disp' table contains a B column named 'addresses' which stores address information for each client. I attempted to join the 'client' and 'disp' tables on the 'client_id' field and then use b_array_elements to extract address details. However, I encountered an error 'cannot extract elements from a scalar' because some entries in the 'addresses' column are not arrays. I need to handle these cases properly to extract the 'PostCode' from the addresses B column for a specific client with client_id = 12345.", "error_sql": ["SELECT \n    client.client_id, \n    client.gender, \n    disp.disp_id, \n    address ->> 'PostCode' AS PostCode\nFROM client\nFULL JOIN disp ON (client.client_id = disp.client_id),\njsonb_array_elements(disp.addresses) AS address\nWHERE disp.client_id = 12345;"], "sol_sql": [], "preprocess_sql": ["ALTER TABLE disp \nADD COLUMN addresses jsonb;", "INSERT INTO disp (disp_id, client_id, account_id, addresses) VALUES\n    (324124, 32323432, 4342443141, '[{\"PostCode\":\"12345\"}]'),\n    (43244241, 3455566, 645634, '[null]'),\n    (42342436, 12345, 5346574, 'null');"], "clean_up_sql": ["\n    DELETE FROM disp \n    WHERE disp_id IN (324124, 43244241, 42342436);\n    ", "\n    ALTER TABLE disp \n    DROP COLUMN addresses;\n    "], "test_cases": [], "issue_type": "Management"}
{"instance_id": 61, "selected_database": "financial", "query": "In the financial database, I want to update the 'amount' in the 'loan' table for a specific 'account_id' and 'date' if it exists, or insert a new record if it does not. However, I do not want the 'loan_id' to increment if an update occurs because it is an auto-incrementing SERIAL column. The 'loan_id' should only increment when a new record is inserted to maintain a sequential order without gaps.", "error_sql": ["\nINSERT INTO loan (\n    loan_id, \n    account_id, \n    date, \n    amount, \n    duration, \n    payments, \n    status\n)\nVALUES (\n    DEFAULT, \n    2, \n    '1996-04-29', \n    30276, \n    12, \n    2523.0, \n    'B'\n)\nON CONFLICT (loan_id, account_id, date)\nDO UPDATE\n    SET amount = loan.amount + 1000;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS loan (loan_id SERIAL PRIMARY KEY, account_id int NOT NULL, date date NOT NULL, amount int NOT NULL, duration int NOT NULL, payments double NOT NULL, status text NOT NULL, UNIQUE(account_id, date)); INSERT INTO loan (loan_id, account_id, date, amount, duration, payments, status) VALUES (134411, 2, '1994-01-05', 80952, 24, 3373.0, 'A');", "\n    DELETE FROM loan t1\n    USING loan t2\n    WHERE t1.account_id = t2.account_id\n      AND t1.date = t2.date\n      AND t1.loan_id > t2.loan_id;\n    ", "ALTER TABLE loan\n    ADD CONSTRAINT loan_accountid_date_uk\n    UNIQUE (account_id, date);"], "clean_up_sql": ["DROP TABLE IF EXISTS loan;"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 62, "selected_database": "card_games", "query": "In our card_games database, we have a large table named cards which contains detailed information about each card. We also have two smaller tables, norm1 and norm2, which contain a subset of the cards based on certain criteria. The goal is to delete rows from the cards table where the combination of (uuid, setCode, rarity, manaCost) does not exist in either norm1 or norm2. The current query uses two separate NOT IN clauses, which is both verbose and potentially inefficient. We need to rewrite this query to make it more concise and performant.", "error_sql": ["DELETE FROM cards WHERE (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM norm1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL) AND (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM norm2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL);"], "sol_sql": [], "preprocess_sql": ["\nCREATE TABLE norm1 AS SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 2 = 0; CREATE TABLE norm2 AS SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 3 = 0;\n"], "clean_up_sql": ["\nDROP TABLE norm1; DROP TABLE norm2;\n"], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 63, "selected_database": "financial", "query": "In the financial database, I want to apply a forward fill function to all nullable columns of a table. The forward fill function should be applied to each column dynamically, given the table name, an ID column, and a row number column. For example, using the 'trans' table, I want to apply the forward fill to all nullable columns, partitioned by 'account_id' and ordered by 'date'. The function should handle any table with nullable columns and apply the forward fill accordingly. However, my initial attempt at writing the function resulted in a syntax error. I need a corrected version of the function that works for any table with nullable columns.", "error_sql": ["CREATE OR REPLACE FUNCTION f_gap_fill_update(tbl text, id text, row_num text) RETURNS void LANGUAGE plpgsql AS $func$ DECLARE tmp text[]; col text; BEGIN select array ( select column_name from information_schema.columns c where table_name = tbl ) into tmp; foreach col in array tmp loop execute 'update '||tbl||' set '||col||' = gapfill('||col||') OVER w AS '||col||' where '||tbl||'.row_num = '||col||'.row_num window w as (PARTITION BY '||id||' ORDER BY '||row_num||') returning *;'; end loop; end $func$;"], "sol_sql": [], "preprocess_sql": ["CREATE OR REPLACE FUNCTION gap_fill_internal(s anyelement, v anyelement) RETURNS anyelement LANGUAGE plpgsql AS $func$ BEGIN RETURN COALESCE(v, s); END $func$; CREATE AGGREGATE gap_fill(anyelement) ( SFUNC = gap_fill_internal, STYPE = anyelement );"], "clean_up_sql": [""], "test_cases": [], "issue_type": "Management"}
{"instance_id": 64, "selected_database": "financial", "query": "In the financial database, there is a table named 'card' that records details of issued cards. Each card is identified by a 'card_id' and is associated with a 'disp_id', along with other details like 'type' and 'issued'. Let's say we want to change the order of a specific 'disp_id' within the same 'type'. For instance, we want to set the 'disp_id' of a card with 'disp_id' = 41 to 1. This change should reorder the 'disp_id' values of all affected cards within the same 'type'. The expected result is that the card with 'disp_id' = 41 should now have 'disp_id' = 1, and the other cards' 'disp_id' values should be incremented accordingly.", "error_sql": ["UPDATE card SET disp_id = 1 WHERE disp_id = 41;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Management"}
{"instance_id": 65, "selected_database": "financial", "query": "I have created the following custom SQL function on a PostgreSQL 16.1 server to generate a series of monthly dates between two given dates for analyzing transaction trends over time:\\nCREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date)\\nRETURNS SETOF date LANGUAGE SQL IMMUTABLE PARALLEL SAFE ROWS 12 AS $function$\\nselect generate_series(date_trunc('month', a), date_trunc('month', b), '1 month')\\n$function$;\\nSpecifically, I have added the row estimate parameter, and as expected, I am seeing this estimate in some simple queries:\\nexplain select generate_series_monthly('2023-01-01', '2023-12-01');\\nHowever, in some uses in queries, I see it falling back to the default of 1000:\\nexplain select * from generate_series_monthly('2023-01-01', '2023-12-01');\\nI would expect this second query to also use the 12 row estimate. Why is it resorting to 1000?", "error_sql": ["CREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date) RETURNS SETOF date LANGUAGE SQL IMMUTABLE PARALLEL SAFE ROWS 10 AS $function$ select generate_series(date_trunc('month', a), date_trunc('month', b), '1 month') $function$; EXPLAIN SELECT generate_series_monthly('2024-01-01', '2024-05-01'); EXPLAIN SELECT * FROM generate_series_monthly('2024-01-01', '2024-05-01');"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Management"}
{"instance_id": 66, "selected_database": "european_football_2", "query": "In the context of european_football_2 database whose match table contains columns such as season, date, home_team_goal, away_team_goal, etc. Now, suppose you want to treat any match ending in a draw (home_team_goal = away_team_goal) as if an invoice were being issued. Between two such draws, you might have several other matches that do not end in a draw, and for each of those matches, you want to treat the total goals scored (i.e., home_team_goal + away_team_goal) like a running amount you accumulate. Finally, you only want to keep the draw rows, and each of those rows should carry the sum of total goals scored since the last draw.", "error_sql": ["SELECT \n    m.id,\n    m.date,\n    CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END AS invoiced,\n    SUM(m.home_team_goal + m.away_team_goal)\n        OVER (PARTITION BY (CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END)\n              ORDER BY m.id, m.date) AS amount\nFROM match AS m\nORDER BY m.id, m.date;"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 67, "selected_database": "debit_card_specializing", "query": "We have a table called transactions_1k that contains transaction details for multiple customers across different gas stations. Each row in this table has:\n1. transaction date\n2. ransaction time\n3. customerid (the ID of the customer)\n4. gasstationid (the ID of the gas station)\n5. productid (the product involved)\n6. amount (the quantity, e.g., liters purchased)\n7. price (the cost)\n\nWe want to filter these transactions under the following rules, per customer:\n1.  Only the last transaction at each gas station should be considered.\n2.  If the customer has any transaction where amount < 10 (which indicates a potential issue), display the first gas station on which that issue occurred.\n3.  If the customer has no transactions with amount < 10, then display the last gas station on which the customer had a transaction with amount >= 10.\n\nGiven some sample data, we expect the final output to show only:\n1. The last transaction for each gas station where amount >= 10.\n2. The first transaction for each gas station where amount < 10.\n\nWe attempted the following SQL query in PostgreSQL to achieve this, but it does not return the desired results. Instead, it only picks the gas station with the maximum gasstationid for each customer and does not correctly determine the earliest occurrence of amount < 10 chronologically. In other words, this query fails to implement \u201cthe last transaction per gas station\u201d and \u201cthe first station where amount < 10\u201d correctly.", "error_sql": ["WITH DataSource AS (\n  SELECT\n    *,\n    MIN(CASE WHEN amount < 10 THEN gasstationid END) \n      OVER (PARTITION BY customerid) AS first_issue_gasstation,\n    ROW_NUMBER() OVER (PARTITION BY customerid ORDER BY gasstationid DESC) AS gasstation_id\n  FROM transactions_1k\n  WHERE gasstationid = (\n    SELECT MAX(gasstationid)\n    FROM transactions_1k\n    WHERE customerid = transactions_1k.customerid\n  )\n)\nSELECT \n  customerid,\n  transactionid,\n  gasstationid,\n  amount\nFROM DataSource\nWHERE\n  (first_issue_gasstation IS NULL AND gasstation_id = 1)\n  OR (first_issue_gasstation = gasstationid);"], "sol_sql": [], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": [], "issue_type": "Query"}
{"instance_id": 68, "selected_database": "superhero", "query": "In the superhero database, we have a directed acyclic graph representing the lineage of superheroes. Each superhero has a unique identifier and a parent identifier, which points to their predecessor in the lineage. Given two superheroes, 'Superhero A' and 'Superhero B', we need to find their common ancestor in the lineage. The provided query is inefficient as it traverses the entire lineage until it finds the root, which is not optimal when the common segment of the lineage is large. We need to find an efficient way to determine the common ancestor with a complexity of O(A+B) where A and B are the number of nodes in the lineages of 'Superhero A' and 'Superhero B', respectively.", "error_sql": ["WITH RECURSIVE linked_list(id, parent_id) AS (SELECT id, parent_id FROM lineage WHERE id = 1001 OR id = 1201 UNION ALL SELECT g.id, g.parent_id FROM lineage g INNER JOIN linked_list ll ON ll.parent_id = g.id) SELECT string_agg(id::TEXT, ',') AS ids, parent_id FROM linked_list GROUP BY parent_id HAVING COUNT(DISTINCT id) > 1;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE lineage (id INT PRIMARY KEY, parent_id INT);", "INSERT INTO lineage (id, parent_id) SELECT i, CASE WHEN i = 1 THEN NULL ELSE i - 1 END FROM generate_series(1, 1000) AS i;", "INSERT INTO lineage (id, parent_id) SELECT 1000 + i, 1000 + i - 1 FROM generate_series(1, 200) AS i;", "INSERT INTO lineage (id, parent_id) SELECT 1200 + i, 1000 + i - 1 FROM generate_series(1, 200) AS i;"], "clean_up_sql": ["DROP TABLE lineage;"], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 69, "selected_database": "card_games", "query": "In a digital card trading platform, users perform various actions such as `LOGIN`, `SEARCH`, and `BUY`. An abandoned `SEARCH` action is defined as when a user `LOGIN`s, performs one or more `SEARCH` actions, and does not perform a `BUY` action before the next `LOGIN`. Given a table `user_actions` that records `user_id`, `action`, and `action_time`, determine all abandoned `SEARCH` actions.", "error_sql": ["SELECT c1.user_id, COUNT(*) FROM user_actions c1 LEFT JOIN (SELECT user_id, action, action_time FROM user_actions WHERE action = 'LOGIN') c2 ON c1.user_id = c2.user_id AND c2.action_time > c1.action_time LEFT JOIN (SELECT user_id, action, action_time FROM user_actions WHERE action = 'BUY') c3 ON c1.user_id = c3.user_id AND c3.action_time > c1.action_time AND c3.action_time < c2.action_time WHERE c1.action = 'SEARCH' AND c2.user_id IS NOT NULL AND c3.user_id IS NULL GROUP BY 1"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE user_actions(user_id VARCHAR(1) NOT NULL, action VARCHAR(6) NOT NULL, action_time DATE NOT NULL);", "INSERT INTO user_actions(user_id, action, action_time) VALUES ('A', 'LOGIN', '2023-05-01'), ('A', 'SEARCH', '2023-05-02'), ('A', 'SEARCH', '2023-05-03'), ('A', 'BUY', '2023-05-04'), ('B', 'LOGIN', '2023-05-01'), ('B', 'SEARCH', '2023-05-02'), ('B', 'SEARCH', '2023-05-03'), ('B', 'LOGIN', '2023-05-04'), ('B', 'SEARCH', '2023-05-05')"], "clean_up_sql": ["DROP TABLE user_actions"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 70, "selected_database": "card_games", "query": "In the card_games database, there is a table named 'cards' which contains various details about each card, including a unique identifier 'id' and the card's name 'name'. Another table named 'decks' stores information about different decks, where each deck has a unique identifier 'id' and an array 'card_order' that lists the 'id's of the cards in the deck in the order they should be played. When a user selects a deck, they want to see the cards in the order they are listed in the 'card_order' array. However, the current SQL query does not preserve the order of the cards as specified in the 'card_order' array. The user's current SQL query is provided below and it does not maintain the order of the cards.", "error_sql": ["SELECT c.id, c.name FROM cards c WHERE c.id IN (SELECT unnest(card_order) FROM decks WHERE id = 1);"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE decks (id bigint PRIMARY KEY, card_order bigint[]);", "INSERT INTO decks (id, card_order) VALUES (1, ARRAY[3, 6, 1]), (2, ARRAY[5, 2, 4]);"], "clean_up_sql": ["DROP TABLE decks;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 71, "selected_database": "card_games", "query": "In the context of the card_games database, we have two tables: 'card_prices' and 'order_cards'. The 'card_prices' table records the price of each card at different start dates, and the 'order_cards' table records the cards ordered by customers on specific dates. We need to join these two tables to get the price of each card at the time it was ordered. However, the initial attempt to join the tables resulted in duplicate records for some orders. Here are the tables and the problematic query:\\n\\Table 'card_prices':\\n| start_date | card_id | price |\\n|------------|---------|-------|\\n| 2023-04-01 | 1       | 10.0  |\\n| 2023-04-15 | 1       | 20.0  |\\n| 2023-04-01 | 2       | 20.0  |\\n\\Table 'order_cards':\\n| order_date | order_id | card_id |\\n|------------|----------|---------|\\n| 2023-04-01 | 10001    | 1       |\\n| 2023-04-01 | 10001    | 2       |\\n| 2023-04-02 | 10002    | 1       |\\n| 2023-04-02 | 10002    | 2       |\\n| 2023-04-16 | 10003    | 1       |\\n| 2023-04-16 | 10003    | 2       |\\n\\nThe desired result is:\\n| order_date | order_id | card_id | price |\\n|------------|----------|---------|-------|\\n| 2023-04-01 | 10001    | 1       | 10.0  |\\n| 2023-04-01 | 10001    | 2       | 20.0  |\\n| 2023-04-02 | 10002    | 1       | 10.0  |\\n| 2023-04-02 | 10002    | 2       | 20.0  |\\n| 2023-04-16 | 10003    | 1       | 20.0  |\\n| 2023-04-16 | 10003    | 2       | 20.0  |\\nHowever, the initial attempt resulted in duplicate records for some orders.\\n", "error_sql": ["SELECT ord.order_date, ord.order_id, ord.card_id, prd.price FROM order_cards ord LEFT JOIN (SELECT * FROM card_prices ORDER BY start_date ASC) AS prd ON ord.card_id = prd.card_id AND ord.order_date >= prd.start_date"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE card_prices (start_date DATE, card_id BIGINT, price NUMERIC);", "INSERT INTO card_prices (start_date, card_id, price) VALUES ('2023-04-01', 1, 10.0), ('2023-04-15', 1, 20.0), ('2023-04-01', 2, 20.0);", "CREATE TABLE order_cards (order_date DATE, order_id BIGINT, card_id BIGINT);", "INSERT INTO order_cards (order_date, order_id, card_id) VALUES ('2023-04-01', 10001, 1), ('2023-04-01', 10001, 2), ('2023-04-02', 10002, 1), ('2023-04-02', 10002, 2), ('2023-04-16', 10003, 1), ('2023-04-16', 10003, 2);"], "clean_up_sql": ["DROP TABLE card_prices;", "DROP TABLE order_cards;"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 72, "selected_database": "european_football_2", "query": "In the database 'european_football_2', there is a table named 'player_stats' that records the performance statistics of football players across different matches. Each row in the table represents a player's performance in a specific match. The table has two columns, 'stats_keys' and 'stats_values', which store the performance metrics and their corresponding values as comma-separated strings. For example, 'stats_keys' might contain 'goals,assists,yellow_cards' and 'stats_values' might contain '2,1,0'. The task is to transform this table into a format where each performance metric is a separate column, with the corresponding values filled in for each player's match performance.", "error_sql": ["select player_id, stats_keys, stats_values from player_stats"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE player_stats (player_id INT, stats_keys TEXT, stats_values TEXT);", "INSERT INTO player_stats (player_id, stats_keys, stats_values) VALUES (1, 'goals,assists,yellow_cards', '2,1,0'), (2, 'assists,yellow_cards', '0,1'), (3, 'goals,yellow_cards', '1,0'), (4, 'assists,yellow_cards,red_cards', '2,1,0');"], "clean_up_sql": ["DROP TABLE player_stats;"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 73, "selected_database": "european_football_2", "query": "In the 'european_football_2' database, there is a table named 'teams_config' which holds information about various football teams. Each team has a 'configurations' column of type jsonb that stores an array of objects representing different team settings. Each object in the array has an 'id', 'name', and 'settings'. For example, one row in the 'teams_config' table might have the following 'configurations':\n[\n    {\n             \"id\": 100, \n            \"name\": \"testOne\", \n            \"settings\": \"settingOne\" \n       },\n         {\n            \"id\": 101,\n            \"name\": \"testTwo\",\n            \"settings\": \"settingTwo\"\n        },\n]", "error_sql": ["UPDATE teams_config SET configurations = jsonb_set(configurations, '{settings}', (configurations->'id') - (SELECT DISTINCT position - 1 FROM teams_config, jsonb_array_elements(configurations) WITH ORDINALITY arr(elem, position) WHERE elem->>'id' = '101')::int);"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE teams_config (configurations jsonb);", "INSERT INTO teams_config VALUES ('[{\"id\": 100, \"name\": \"testOne\", \"settings\": \"settingOne\"}, {\"id\": 101, \"name\": \"testTwo\", \"settings\": \"settingTwo\"}]');"], "clean_up_sql": ["DROP TABLE teams_config"], "test_cases": [], "issue_type": "Management"}
{"instance_id": 74, "selected_database": "formula_1", "query": "I have a table race_dates which stores the begin_date and end_date of races, e.g. '2022-01-03' and '2022-03-04', is there any neat way to calculate ONLY the completed full calendar months between these dates? Some examples with their requested outputs: '2022-01-03' and '2022-03-04' full calendar months = 1 since only February was a full calendar month between this timespan. '2022-01-01' and '2022-05-30' full calendar months = 4 since May has 31 days total. '2022-01-31' and '2022-05-31' full calendar months = 3 since the month of May is not completed. I tried subtracting the dates but it gives me the days difference between these dates. I also tried the function AGE() but it is based also in the days difference, since it is using days to calculate years months etc.", "error_sql": ["SELECT begin_date, end_date, age(CASE WHEN end_date = date_trunc('month', end_date) + interval '1 month - 1 day' THEN end_date + interval '1 day' ELSE date_trunc('month', end_date) END::date, CASE WHEN begin_date = date_trunc('month', begin_date) THEN begin_date ELSE date_trunc('month', begin_date) + interval '1 month' END::date) AS calculated_months FROM race_dates;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE race_dates (begin_date DATE NOT NULL, end_date DATE NOT NULL)", "INSERT INTO race_dates (begin_date, end_date) VALUES ('2022-01-03', '2022-03-04'), ('2022-01-01', '2022-05-30'), ('2022-01-31', '2022-05-31'), ('2021-11-15', '2022-02-10'), ('2021-12-01', '2022-05-31');"], "clean_up_sql": ["DROP TABLE race_dates"], "test_cases": [], "issue_type": "Query"}
{"instance_id": 75, "selected_database": "student_club", "query": "In the student_club database, I am trying to insert an attendance record that tracks when a member attends an event. The goal is to ensure there are no duplicate entries for the same member attending the same event. If an attendance record for the member and event already exists, the date column should be updated to reflect the most recent attendance timestamp. If no such record exists, a new record should be created. I have tried using the ON CONFLICT clause with a WHERE condition to achieve this, but it doesn't seem to work.\nHere is one of the many permutations I've tried:\n\nsql\nINSERT INTO new_attendance (link_to_event, link_to_member, date) \nVALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW()) \nON CONFLICT \n   WHERE link_to_member='recL94zpn6Xh6kQii' DO NOTHING\n\n\nThe link_to_member column does not have any constraints, so the simpler syntax:\n\nsql\nON CONFLICT (link_to_member) DO NOTHING\n\n\nthrows database errors. My hope is this is a simple syntax issue.", "error_sql": ["\n    INSERT INTO new_attendance (link_to_event, link_to_member, date)\n    VALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW())\n    ON CONFLICT\n    WHERE link_to_member='recL94zpn6Xh6kQii' DO NOTHING;\n    "], "sol_sql": [], "preprocess_sql": ["\n    DROP TABLE IF EXISTS new_attendance;\n    ", "\n    CREATE TABLE new_attendance AS\n    SELECT DISTINCT link_to_event, link_to_member, NOW() AS date\n    FROM attendance;\n    ", "\n    ALTER TABLE new_attendance\n    ADD CONSTRAINT unique_event_member UNIQUE (link_to_event, link_to_member);\n    "], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 76, "selected_database": "financial", "query": "I'm migrating from Oracle to PostgreSQL. In Oracle, I used the following call to acquire a lock with a timeout: `lkstat := DBMS_LOCK.REQUEST(lkhndl, DBMS_LOCK.X_MODE, lktimeout, true);`. This function tries to acquire the lock `lkhndl` and returns 1 if it fails to get it after `lktimeout` seconds. In PostgreSQL, I tried using `pg_advisory_xact_lock(lkhndl);`, but it seems to wait indefinitely for the lock.     I need a way to implement a timeout version of lock acquiring in PostgreSQL named pg_try_advisory_lock_with_timeout. The function pg_try_advisory_lock_with_timeout(key bigint) is designed to attempt to acquire a PostgreSQL advisory lock with a timeout of 1 second. If the lock is unavailable due to contention or deadlock detection, it will return false instead of waiting indefinitely.", "error_sql": ["\n        pg_advisory_xact_lock(lkhndl);\n        "], "sol_sql": [], "preprocess_sql": ["\n    DROP FUNCTION IF EXISTS pg_try_advisory_lock_with_timeout(bigint);\n    "], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 77, "selected_database": "student_club", "query": "I'm trying to rank club members based on the hours they have attented for events, rounded to the nearest 10. I need to produce a descending ranking of members by total hours attened, including a column with the rank using the `RANK()` window function, and sort the result by the rank. However, my rounding logic seems to be incorrect, as it produces different results compared to the expected output.", "error_sql": ["\n        SELECT\n            link_to_member,\n            CASE\n                WHEN (SUBSTRING(ROUND(SUM(hours)::NUMERIC, 0)::TEXT FROM '.{1}$') IN ('5', '6', '7', '8', '9', '0')) \n                THEN CEIL(SUM(hours) / 10) * 10\n                ELSE FLOOR(SUM(hours) / 10) * 10\n            END AS rounded_hours,\n            RANK() OVER (ORDER BY \n                CASE\n                    WHEN (SUBSTRING(ROUND(SUM(hours)::NUMERIC, 0)::TEXT FROM '.{1}$') IN ('5', '6', '7', '8', '9', '0')) \n                    THEN CEIL(SUM(hours) / 10) * 10\n                    ELSE FLOOR(SUM(hours) / 10) * 10\n                END DESC\n            ) AS rank\n        FROM attendance\n        GROUP BY link_to_member\n        ORDER BY rank, link_to_member;      \n        "], "sol_sql": [], "preprocess_sql": ["\n    ALTER TABLE attendance\n    ADD COLUMN hours NUMERIC;\n    ", "\n    TRUNCATE TABLE attendance;\n    ", "\n    INSERT INTO attendance (link_to_event, link_to_member, hours)\n    VALUES \n    ('event_1', 'member_1', 64.5),\n    ('event_2', 'member_1', 60.0),\n    ('event_2', 'member_2', 210.5),\n    ('event_3', 'member_3', 237.6);\n    "], "clean_up_sql": [], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 78, "selected_database": "financial", "query": "I need to create an index named ix_account on the 'account' table for the columns 'district_id', 'frequency', and 'date'. I want to ensure that the index does not already exist before attempting to create it. How can I check for the existence of this index? Return True if the index exists. Otherwise return False.", "error_sql": ["\n        CREATE INDEX ix_account ON account USING btree (district_id, frequency, date);   \n        "], "sol_sql": [], "preprocess_sql": ["\n        CREATE INDEX ix_account ON account USING btree (district_id, frequency, date);   \n        "], "clean_up_sql": [], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 79, "selected_database": "european_football_2", "query": "I am trying to create a view that counts the records where home team goal is 2 in a specific season.     I have a function `findteam(text)` that returns a float representing the count for a given season.    However, when I try to use this function in my view, I encounter an error stating 'cannot change data type of view column `team_count` from integer to double precision'.     I am new to SQL and do not understand why this is happening or how to fix it.", "error_sql": ["\n        create or replace view findcount(season, team_count) as\n        select\n            season,\n            findteam(season) as team_count\n        from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n        "], "sol_sql": [], "preprocess_sql": ["\n    DROP VIEW IF EXISTS findcount;\n    DROP FUNCTION IF EXISTS findteam;\n    ", "\n    create or replace function findteam(text) returns float as $$\n    select cast(count(*) as float)\n    from match m\n    where m.home_team_goal = 2 and m.season = $1;\n    $$ language sql;\n    ", "\n    CREATE VIEW findcount AS\n    SELECT season, CAST(10 AS INTEGER) AS team_count\n    from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n    "], "clean_up_sql": [], "test_cases": [], "issue_type": "Management"}
{"instance_id": 80, "selected_database": "codebase_community", "query": "In the context of the 'codebase_community' database, a user has a table named 'posts' containing various posts made by users. Each post has a 'tags' column    that lists the tags associated with the post. Specifically, the user is interested in identifying the number of posts that include the keywords 'bayesian' or 'distributions' for each post type.    The user attempted to implement this in PostgreSQL but encountered errors in his SQL query.", "error_sql": ["\n        select posttypeid\n        case when tags like ('%bayesian%','%distributions%') \n        then 1 else 0 end as keyword_count\n        from posts\n        "], "sol_sql": [], "preprocess_sql": ["\n    ALTER TABLE posts RENAME TO posts_backup;\n    ", "\n    CREATE TABLE posts (\n    id INT PRIMARY KEY,\n    posttypeid INT,\n    tags TEXT\n    );\n    ", "\n    INSERT INTO posts (id, posttypeid, tags)\n    VALUES \n    (1, 1, '<bayesian><prior><elicitation>'),\n    (2, 1, '<distributions><normality>'),\n    (3, 1, '<software><open-source>'),\n    (4, 2, '<distributions>'),\n    (5, 2, '<book><code>');\n    ", "\n    DROP TABLE IF EXISTS posts_backup;\n    "], "clean_up_sql": [], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 81, "selected_database": "debit_card_specializing", "query": "I have a table of transactions for multiple customers, where each transaction has a unique transaction id, along with amount, type, and transaction record. Some transactions for a single customerid share the same combination of these attributes. I want to update a first_transaction column with the transaction of the earliest transaction for each unique combination of attributes within each customer. My current method uses a LATERAL JOIN but is extremely slow on my small server. I process one customer at a time and commit after each iteration, but the query remains inefficient. How can I optimize this process?", "error_sql": ["SELECT a.customerid, a.transaction, (SELECT b.transaction FROM transaction_info b WHERE b.customerid = a.customerid AND b.amount = a.amount AND b.type = a.type ORDER BY b.transaction LIMIT 1) AS first_transaction, a.amount, a.type, a.transactionid FROM transaction_info a ORDER BY a.customerid, a.transaction"], "sol_sql": [], "preprocess_sql": ["\nCREATE TABLE transaction_info (\n  customerid int,\n  transaction int,\n  first_transaction varchar(10),\n  amount numeric,\n  type numeric,\n  transactionid text\n);\nINSERT INTO transaction_info (customerid, transaction, first_transaction, amount, type, transactionid) VALUES\n(1, 1, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F'),\n(1, 2, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F'),\n(1, 3, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F'),\n(1, 4, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F'),\n(1, 5, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F'),\n(1, 6, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F');            \n"], "clean_up_sql": ["\nDROP TABLE test;\n"], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
{"instance_id": 82, "selected_database": "toxicology", "query": "In the toxicology database, I have two tables, 'bond' and 'molecule'. The 'bond' table contains information about bonds within molecules, including a foreign key 'molecule_id' that references the 'molecule' table. I need to construct a query that select count(*), molecule_id, most recent update timestamp grouping the bonds by 'molecule_id' and sorts the results based on molecule_id and the most recent bond entry (assuming we have a timestamp column added to the 'bond' table for this purpose). However, I've tried the following query and it doesn't work as expected:", "error_sql": ["SELECT count(bond_id), molecule_id FROM bond GROUP BY molecule_id ORDER BY molecule_id last_update DESC;"], "sol_sql": [], "preprocess_sql": ["ALTER TABLE bond ADD COLUMN last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP;"], "clean_up_sql": ["ALTER TABLE bond DROP COLUMN last_update;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 83, "selected_database": "european_football_2", "query": "In the context of the 'european_football_2' database, we have a table that logs changes to player statistics over time. Each row in the 'player_stats_changes' table represents a change to a specific player's attribute (such as height or weight) at a particular timestamp. We want to generate a cumulative view of these changes, where each row shows the player's current height and weight at each timestamp, filling in any missing values with the most recent known value.", "error_sql": ["SELECT entity_id, coalesce(change->'height', lag(change->'height', 1, null) over (partition by entity_id order by updated_at)) as height, coalesce(change->'weight', lag(change->'weight', 1, null) over (partition by entity_id order by updated_at)) as weight, updated_at FROM ( SELECT entity_id, json_object_agg(column_id, value) as change, updated_at FROM player_stats_changes GROUP BY entity_id, updated_at) as changes;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS player_stats_changes ( entity_id TEXT NOT NULL, column_id TEXT NOT NULL, value JSONB NOT NULL, updated_at TIMESTAMP NOT NULL );", "INSERT INTO player_stats_changes VALUES ('1', 'height', to_jsonb(140), '01-01-2021 00:00:00'::TIMESTAMP), ('1', 'weight', to_jsonb(30), '01-01-2021 00:00:00'::TIMESTAMP), ('1', 'height', to_jsonb(145), '01-02-2021 00:00:00'::TIMESTAMP), ('1', 'weight', to_jsonb(34), '01-03-2021 00:00:00'::TIMESTAMP);"], "clean_up_sql": ["DROP TABLE IF EXISTS player_stats_changes;"], "test_cases": [], "issue_type": "Personalization"}
{"instance_id": 84, "selected_database": "superhero", "query": "In the superhero database, I have two separate queries (q1, q2) joining across multiple tables assigning the same superheroes to different groups (I call these subgroups) based on different criteria. I get query result 1 and 2 (qr1, qr2). An item might appear in one or both, but within a result it is unique. I want to assign a new group id based on both subgroups and assigning the same group id if the subgroups share one or more items.", "error_sql": ["with qr1(item, subgroup) AS (SELECT id, subgroup1 FROM superhero_group WHERE subgroup1 IS NOT NULL), qr2(item, subgroup) AS (SELECT id, subgroup2 FROM superhero_group WHERE subgroup2 IS NOT NULL) select item, subgroup1, subgroup2, dense_rank() over (order by item) as group from (select qr1.item, qr1.subgroup as subgroup1, qr2.subgroup as subgroup2 from qr1 full outer join qr2 on qr1.item = qr2.item) as combined"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE superhero_group (id INTEGER PRIMARY KEY, subgroup1 INTEGER, subgroup2 INTEGER)", "INSERT INTO superhero_group VALUES (1,1,5), (2,1,null), (3,2,null), (4,3,null), (5,3,6), (6,4,6), (7,null,7), (8,null,5), (10,null,5)"], "clean_up_sql": [], "test_cases": [], "issue_type": "Query"}
{"instance_id": 85, "selected_database": "superhero", "query": "In the superhero database, a user is allowed to view details of a superhero if their user_id matches the superhero's publisher_id or if there is an entry in the 'hero_access' table where their user_id is in the 'read_acl' column (array using gin index). Both tables have about 2 million rows. The query is slow, especially when using an OR clause. Is there a way that improves the performance significantly?", "error_sql": ["select * from superhero where publisher_id = 1 or exists (select * from hero_access f where superhero.id = f.superhero_id and '{1}' && read_acl) order by superhero.id limit 10;"], "sol_sql": [], "preprocess_sql": ["CREATE TABLE hero_access (superhero_id bigint, read_acl text[]);", "CREATE INDEX idx_hero_access_read_acl ON hero_access USING gin (read_acl);", "INSERT INTO hero_access (superhero_id, read_acl) SELECT id, ARRAY['1'] FROM superhero ORDER BY random() LIMIT 10;"], "clean_up_sql": ["DROP TABLE hero_access;"], "test_cases": [], "efficiency": true, "issue_type": "Efficiency"}
